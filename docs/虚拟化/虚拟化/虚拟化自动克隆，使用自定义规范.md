[https://techdocs.broadcom.com/cn/zh-cn/vmware-cis/vsphere/vsphere/8-0/vsphere-virtual-machine-administration-guide-8-0/managing-virtual-machinesvsphere-vm-admin/customizing-guest-operating-systemsvsphere-vm-admin/create-and-manage-customization-specificationsvsphere-vm-admin.html](https://techdocs.broadcom.com/cn/zh-cn/vmware-cis/vsphere/vsphere/8-0/vsphere-virtual-machine-administration-guide-8-0/managing-virtual-machinesvsphere-vm-admin/customizing-guest-operating-systemsvsphere-vm-admin/create-and-manage-customization-specificationsvsphere-vm-admin.html)

<font style="color:rgb(0, 0, 0);">è¿è¡Œè‡ªå®šä¹‰è„šæœ¬ï¼š</font>

+ <font style="color:rgb(0, 0, 0);">ç¡®è®¤å·²å®‰è£… VMware Tools ç‰ˆæœ¬ 10.1.0 æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚å¦‚æœ VMware Tools ç‰ˆæœ¬ä½äº 10.1.0ï¼Œåˆ™æ‚¨å°è¯•è¿è¡Œè‡ªå®šä¹‰è„šæœ¬æ—¶ï¼Œè‡ªå®šä¹‰å°†å¤±è´¥ã€‚</font>
+ <font style="color:rgb(0, 0, 0);">åœ¨ VMware Tools é…ç½®ä¸­ï¼Œå‡ºäºå®‰å…¨åŸå› ï¼Œenable-custom-scripts é€‰é¡¹é»˜è®¤å¤„äºå–æ¶ˆæ¿€æ´»çŠ¶æ€ã€‚å°è¯•åœ¨ enable-custom-scripts é€‰é¡¹å¤„äºå–æ¶ˆæ¿€æ´»çŠ¶æ€çš„æƒ…å†µä¸‹è¿è¡Œè‡ªå®šä¹‰è„šæœ¬æ—¶ï¼Œè‡ªå®šä¹‰å°†å¤±è´¥å¹¶æ˜¾ç¤ºè‡ªå®šä¹‰é”™è¯¯ã€‚ä¾‹å¦‚ï¼Œè¦å¯ç”¨ enable-custom-scripts é€‰é¡¹ï¼Œå¿…é¡»ä½¿ç”¨ config å‘½ä»¤ä»¥ root ç”¨æˆ·èº«ä»½è¿è¡Œ vmware-toolbox-cmdï¼š</font>

```plain
vmware-toolbox-cmd config set deployPkg enable-custom-scripts true
cat /etc/vmware-tools/tools.conf
[deployPkg]
enable-custom-scripts = true
```

<font style="color:rgb(0, 0, 0);">è¦éªŒè¯æ˜¯å¦æ­£ç¡®è®¾ç½®äº†è¯¥é€‰é¡¹ï¼Œå¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š</font>

```plain
vmware-toolbox-cmd config get deployPkg enable-custom-scripts
[deployPkg] enable-custom-scripts = true
```

```powershell
cd 'c:\Profile Files\VMware\VMware Tools\'
.\VMwareToolboxCmd.exe config get deployPkg enable-custom-scripts
.\VMwareToolboxCmd.exe config set deployPkg enable-custom-scripts true
.\VMwareToolboxCmd.exe config get deployPkg enable-custom-scripts
```





å®‰è£…perl

```python
mkdir -p /mnt/cdrom
mount /dev/sr0 /mnt/cdrom
cat > /etc/yum.repos.d/rhel8-local.repo <<EOF
[BaseOS]
name=RHEL 8.10 BaseOS
baseurl=file:///mnt/cdrom/BaseOS
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release

[AppStream]
name=RHEL 8.10 AppStream
baseurl=file:///mnt/cdrom/AppStream
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release
EOF


dnf install -y perl
```

å¯é€‰ï¼Œé¿å…åç»­å¤±æ•ˆ

```python
tee > /etc/systemd/system/vmware-custom-scripts.service << 'EOF'
[Unit]
Description=Enable VMware Custom Scripts
After=vmware-tools.service

[Service]
Type=oneshot
ExecStart=/usr/bin/vmware-toolbox-cmd config set deployPkg enable-custom-scripts true

[Install]
WantedBy=multi-user.target
EOF
sudo systemctl daemon-reload
sudo systemctl enable vmware-custom-scripts.service
```

pythonå®ç°

[https://gitee.com/sdfsdfs445/vsphere-scripts.git](https://gitee.com/sdfsdfs445/vsphere-scripts.git)

èŒƒä¾‹

| **<font style="color:#000000;">vm_note</font>** | **<font style="color:#000000;">vm_type</font>** | **<font style="color:#000000;">vm_name</font>** | **<font style="color:#000000;">template</font>** | **<font style="color:#000000;">disk_size</font>** | **<font style="color:#000000;">vm_ip</font>** | **<font style="color:#000000;">vm_gateway</font>** | **<font style="color:#000000;">vm_netmask</font>** | **<font style="color:#000000;">vm_dns</font>** | **<font style="color:#000000;">vm_vlan_name</font>** | **<font style="color:#000000;">vm_cpu</font>** | **<font style="color:#000000;">vm_memory</font>** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">windows</font> | <font style="color:#000000;">AD-M-kehua-xm1</font> | <font style="color:#000000;">windows2019-template</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.108.7</font> | <font style="color:#000000;">192.168.108.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan108</font> | <font style="color:#000000;">4</font> | <font style="color:#000000;">16</font> |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">linux</font> | <font style="color:#000000;">test-archery</font> | <font style="color:#000000;">rhelmini8.10-template-100G</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.107.65</font> | <font style="color:#000000;">192.168.107.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan107</font> | <font style="color:#000000;">8</font> | <font style="color:#000000;">16</font> |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">windows</font> | <font style="color:#000000;">AD-M-kehua-xm1</font> | <font style="color:#000000;">windows2016-template</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.108.7</font> | <font style="color:#000000;">192.168.108.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan108</font> | <font style="color:#000000;">4</font> | <font style="color:#000000;">16</font> |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">linux</font> | <font style="color:#000000;">test-archery</font> | <font style="color:#000000;">rhelmini7.9-template-100G</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.107.65</font> | <font style="color:#000000;">192.168.107.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan107</font> | <font style="color:#000000;">8</font> | <font style="color:#000000;">16</font> |


é€šè¿‡xlsxè°ƒç”¨exeæ–‡ä»¶è¿›è¡Œæ‰¹é‡åˆ›å»º

```python
import subprocess
import pandas as pd
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
# vCenter é€šç”¨ä¿¡æ¯
VCENTER_IP = "192.168.56.xxx"
VCENTER_USER = "xxx@xxx.org"
VCENTER_PASS = "xxxx"
NO_SSL = "-nossl"
THREADS = 3  # çº¿ç¨‹æ•°
# å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„
EXE_WINDOWS = "create_cus_rule_by_windows.exe"
EXE_LINUX = "create_cus_rule_by_bash.exe"
import re

def escape_note(text):
    # Windows CMD ä¸­è¿™äº›å­—ç¬¦æœ‰ç‰¹æ®Šå«ä¹‰ï¼š< > | & ^ % ! "
    return re.sub(r'([<>&|^%!"])', r'^\1', text)  # ^è¿›è¡Œè½¬ä¹‰



def run_create_vm(row):
    vm_type = row['vm_type']
    exe = EXE_WINDOWS if vm_type.lower() == "windows" else EXE_LINUX
    note = str(row['vm_note']).replace('"', "'")  # é¿å…åŒå¼•å·å†²çª
    cmd = [
        f".\\{exe}",
        "-s", VCENTER_IP,
        "-u", VCENTER_USER,
        "-p", VCENTER_PASS,
        NO_SSL,
        "--template", str(row["template"]),
        "--disk-size", str(row["disk_size"]),
        "-v", str(row["vm_name"]),
        "--vm_ip", str(row["vm_ip"]),
        "--vm_gateway", str(row["vm_gateway"]),
        "--vm_netmask", str(row["vm_netmask"]),
        "--vm_dns", str(row["vm_dns"]),
        "--vm_vlan_name", str(row["vm_vlan_name"]),
        "--vm_cpu", str(row["vm_cpu"]),
        "--vm_memory", str(row["vm_memory"]),
        "--vm_note", f'"{note}"',   # ç”¨åŒå¼•å·åŒ…è£¹å®Œæ•´å¤‡æ³¨å­—ç¬¦ä¸²
    ]
    try:
        print(f"ğŸŸ¡ æ­£åœ¨åˆ›å»ºè™šæ‹Ÿæœºï¼š{row['vm_name']}")
        result = subprocess.run(cmd, capture_output=True, text=True, shell=True)
        with open(f"log_{row['vm_name']}.log", "w", encoding="utf-8") as f:
            f.write(result.stdout + "\n" + result.stderr)
        if result.returncode == 0:
            print(f"ğŸŸ¢ è™šæ‹Ÿæœº {row['vm_name']} åˆ›å»ºæˆåŠŸ")
            print(result.stdout)
        else:
            print(f"ğŸ”´ è™šæ‹Ÿæœº {row['vm_name']} åˆ›å»ºå¤±è´¥ï¼š\n{result.stderr}")
    except Exception as e:
        print(f"ğŸ”´ è™šæ‹Ÿæœº {row['vm_name']} åˆ›å»ºå¼‚å¸¸ï¼š{str(e)}")

def main():
    # ä» Excel è¯»å–
    df = pd.read_excel("vm_list.xlsx",sheet_name="VMList")

    # ä½¿ç”¨çº¿ç¨‹åˆ›å»ºè™šæ‹Ÿæœº
    # ä½¿ç”¨çº¿ç¨‹æ± ï¼Œæ¯æ¬¡å¹¶å‘ 3 å°è™šæ‹Ÿæœº
    with ThreadPoolExecutor(max_workers=THREADS) as executor:
        futures = [executor.submit(run_create_vm, row) for index, row in df.iterrows()]
        for future in as_completed(futures):
            future.result()  # æ•è·å¼‚å¸¸

    print("âœ… æ‰€æœ‰è™šæ‹Ÿæœºåˆ›å»ºä»»åŠ¡å·²å®Œæˆã€‚")

if __name__ == "__main__":
    main()

```

å·²ç»å®ç°rhel 7/8 debian12çš„ipè‡ªåŠ¨é…ç½®ï¼Œlvmè‡ªåŠ¨æŒ‚è½½

```python
import threading
import time

from pyVmomi import vim
from tools import cli, service_instance, pchelper
from pyVim.task import WaitForTask


def wait_for_task(task):
    """ ç­‰å¾… vCenter ä»»åŠ¡å®Œæˆ """
    task_done = False
    while not task_done:
        if task.info.state == 'success':
            return task.info.result
        if task.info.state == 'error':
            print("å‡ºç°é”™è¯¯")
            print(task.info.error)
            task_done = True



def set_note(vm, annotation):
    # åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿæœºé…ç½®è§„èŒƒï¼Œå¹¶è®¾ç½®å¤‡æ³¨
    spec = vim.vm.ConfigSpec()
    spec.annotation = annotation

    # æäº¤é…ç½®ä»»åŠ¡
    task = vm.ReconfigVM_Task(spec)
    while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
        continue

    print(f"å·²æ›´æ–°è™šæ‹Ÿæœº{vm.name}çš„å¤‡æ³¨ä¸ºï¼š{annotation}")
def check_vm_tool(vm, timeout=30):
    temp = 0
    while True:
        time.sleep(1)
        temp = temp + 1
        try:
            print(f"toolçŠ¶æ€æ£€æŸ¥ä¸­ç¬¬{temp}æ¬¡")
            if vm.guest.toolsStatus == "toolsOk":
                break
        except Exception as e:
            print(f"é”™è¯¯{e}")
            break
        if temp == timeout:
            print(f"è¶…æ—¶")
            break


def run_script_in_vm(si, vm, script_text, username, password, os_type='linux'):
    """
    åœ¨è™šæ‹Ÿæœºä¸­é€šè¿‡ VMware Tools æ‰§è¡Œè„šæœ¬ï¼Œæ”¯æŒ Linux å’Œ Windows
    :param si: æœåŠ¡å®ä¾‹
    :param vm: è™šæ‹Ÿæœºå¯¹è±¡
    :param script_text: éœ€è¦æ‰§è¡Œçš„è„šæœ¬å†…å®¹
    :param username: è™šæ‹Ÿæœºçš„ç”¨æˆ·å
    :param password: è™šæ‹Ÿæœºçš„å¯†ç 
    :param os_type: è™šæ‹Ÿæœºæ“ä½œç³»ç»Ÿç±»å‹ï¼Œ'linux' æˆ– 'windows'
    """
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)

    pm = si.content.guestOperationsManager.processManager

    if os_type.lower() == 'linux':
        # Linux ç”¨ /bin/bash æ‰§è¡Œ
        program_path = '/bin/bash'
        arguments = fr'-c "{script_text}"'
        print(f'ä¼ å…¥{arguments}')
    elif os_type.lower() == 'windows':
        # Windows ç”¨ cmd.exe /c æ‰§è¡Œï¼Œè„šæœ¬å†™æˆä¸€æ¡å‘½ä»¤
        program_path = r'C:\Windows\System32\cmd.exe'
        # Windows cmd æ‰§è¡Œè„šæœ¬æ—¶éœ€è¦è½¬ä¹‰åŒå¼•å·ï¼Œä¸” /c åæ¥å‘½ä»¤
        # è¿™é‡Œç”¨ä¸€æ¡å‘½ä»¤æ‰§è¡Œï¼Œå¦‚æœæ˜¯å¤šè¡Œå¤æ‚è„šæœ¬å»ºè®®å…ˆä¸Šä¼ è„šæœ¬æ–‡ä»¶å†æ‰§è¡Œ
        # ç›´æ¥ä¼ è„šæœ¬å†…å®¹æ—¶å»ºè®®å†™æˆå•æ¡å‘½ä»¤æˆ–ç”¨ & è¿æ¥å¤šä¸ªå‘½ä»¤
        escaped_script = script_text.replace('"', '\\"')
        arguments = f'/c "{escaped_script}"'
    else:
        raise ValueError(f"ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿç±»å‹: {os_type}")

    ps = vim.vm.guest.ProcessManager.ProgramSpec(programPath=program_path, arguments=arguments)
    pid = pm.StartProgramInGuest(vm, creds, ps)
    print(f"å·²åœ¨è™šæ‹Ÿæœº {vm.name} ä¸­å¯åŠ¨è¿›ç¨‹ï¼ŒPID: {pid}")
    return pid


def run_program_in_guest_sync(si, vm, username, password, program_path, arguments, timeout=300):
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    pm = si.content.guestOperationsManager.processManager

    ps = vim.vm.guest.ProcessManager.ProgramSpec(programPath=program_path, arguments=arguments)
    pid = pm.StartProgramInGuest(vm, creds, ps)
    print(f"å¯åŠ¨è¿›ç¨‹ PID: {pid}")

    start_time = time.time()
    while True:
        processes = pm.ListProcessesInGuest(vm, creds, [pid])
        if not processes:
            print("è¿›ç¨‹ä¸å­˜åœ¨ï¼Œå¯èƒ½å·²ç»ç»“æŸã€‚")
            break
        proc = processes[0]
        if proc.exitCode is not None:
            print(f"è¿›ç¨‹å·²ç»“æŸï¼Œé€€å‡ºç : {proc.exitCode}")
            return proc.exitCode
        if time.time() - start_time > timeout:
            print("ç­‰å¾…è¿›ç¨‹è¶…æ—¶ï¼Œç»“æŸç­‰å¾…")
            return None
        time.sleep(2)


def upload_file(si, vm, local_content, remote_path, username, password):
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    file_manager = si.content.guestOperationsManager.fileManager

    # å…ˆæŠŠå†…å®¹è½¬æˆbytes
    data = local_content.encode('utf-8')

    # è®¡ç®—æ–‡ä»¶å¤§å°
    file_size = len(data)

    # ä¸Šä¼ æ–‡ä»¶çš„URLï¼ˆéœ€è¦ç”¨fileManagerè·å–ä¸Šä¼ URLï¼‰
    url = file_manager.InitiateFileTransferToGuest(vm, creds, remote_path,
                                                   vim.vm.guest.FileManager.FileAttributes(),
                                                   file_size, True)


def upload_script_and_run_sync(si, vm, script_content, remote_path,username, password, timeout=300):
    import base64
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    gm = si.content.guestOperationsManager.fileManager
    pm = si.content.guestOperationsManager.processManager

    # base64 ç¼–ç è„šæœ¬å†…å®¹
    encoded_script = base64.b64encode(script_content.encode('utf-8')).decode('utf-8')

    # é€šè¿‡ echo base64 è§£ç å†™æ–‡ä»¶çš„å‘½ä»¤
    script_cmd = f"echo {encoded_script} | base64 -d > {remote_path} && chmod +x {remote_path} && {remote_path}"
    # å¯åŠ¨ä¸Šä¼ è¿›ç¨‹
    program_spec_upload = vim.vm.guest.ProcessManager.ProgramSpec(
        programPath="/bin/bash",
        arguments=f"-c \"{script_cmd}\""
    )
    pid_upload = pm.StartProgramInGuest(vm, creds, program_spec_upload)
    print(f"ä¸Šä¼ è„šæœ¬å¹¶ä¸”æ‰§è¡Œè¿›ç¨‹PID: {pid_upload}")

    # è½®è¯¢ç­‰å¾…è¿›ç¨‹ç»“æŸ
    start_time = time.time()
    while True:
        processes = pm.ListProcessesInGuest(vm, creds, [pid_upload])
        if not processes:
            print("è¿›ç¨‹ä¸å­˜åœ¨ï¼Œå¯èƒ½å·²ç»“æŸã€‚")
            return None
        proc = processes[0]
        if proc.exitCode is not None:
            print(f"ä¸Šä¼ è¿›ç¨‹å·²ç»“æŸï¼Œé€€å‡ºç : {proc.exitCode}")
            return proc.exitCode
        if time.time() - start_time > timeout:
            print("ä¸Šä¼ è¿›ç¨‹ç­‰å¾…è¶…æ—¶")
            return None
        time.sleep(2)


def update_nic_network(si, vm_name, new_network_name):
    """
    ä¿®æ”¹è™šæ‹Ÿæœºç¬¬ä¸€å—ç½‘å¡è¿æ¥çš„ç½‘ç»œæ ‡ç­¾ï¼ˆç«¯å£ç»„ï¼‰
    :param si: vSphere service instance
    :param vm: è™šæ‹Ÿæœºå¯¹è±¡
    :param new_network_name: æ–°çš„ç½‘ç»œæ ‡ç­¾ï¼ˆç«¯å£ç»„åç§°ï¼‰
    """
    content = si.RetrieveContent()
    new_network = pchelper.get_obj(content, [vim.Network], new_network_name)
    if not new_network:
        raise RuntimeError(f"æ‰¾ä¸åˆ°ç½‘ç»œæ ‡ç­¾ï¼š{new_network_name}")
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        raise RuntimeError(f"æœªæ‰¾åˆ°è™šæ‹Ÿæœº{vm_name}")
    # æŸ¥æ‰¾ç°æœ‰çš„ç½‘å¡è®¾å¤‡ï¼ˆä»¥ç¬¬ä¸€å—ä¸ºä¾‹ï¼‰
    nic_device = None
    for device in vm.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if not nic_device:
        raise RuntimeError("æœªæ‰¾åˆ°è™šæ‹Ÿæœºç½‘å¡")

    # ä¿®æ”¹ backingï¼ˆæ ‡å‡†ç«¯å£ç»„æˆ–åˆ†å¸ƒå¼äº¤æ¢æœºï¼‰
    if isinstance(new_network, vim.dvs.DistributedVirtualPortgroup):
        port = vim.dvs.PortConnection()
        port.portgroupKey = new_network.key
        port.switchUuid = new_network.config.distributedVirtualSwitch.uuid

        nic_device.backing = vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo()
        nic_device.backing.port = port
    else:
        nic_device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
        nic_device.backing.deviceName = new_network_name
        nic_device.backing.network = new_network

    # âœ… å¼€å¯ç½‘å¡è¿æ¥å¹¶å‹¾é€‰â€œå¼€æœºæ—¶è¿æ¥â€
    nic_device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
    nic_device.connectable.startConnected = True  # å¼€æœºè‡ªè¿æ¥
    nic_device.connectable.allowGuestControl = True
    nic_device.connectable.connected = True

    # æ„é€ é…ç½® spec
    nic_spec = vim.vm.device.VirtualDeviceSpec()
    nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    nic_spec.device = nic_device

    spec = vim.vm.ConfigSpec()
    spec.deviceChange = [nic_spec]

    # åº”ç”¨é…ç½®
    task = vm.ReconfigVM_Task(spec=spec)
    wait_for_task(task)
    print(f"å·²ä¿®æ”¹ç½‘å¡è¿æ¥åˆ°ç½‘ç»œï¼š{new_network_name}")


def clone_vm_with_customization(content, template_name, vm_name, datacenter_name, vm_folder, datastore_name,
                                cluster_name, resource_pool, power_on, datastorecluster_name, customization_spec,
                                cpu, memory):
    """
    ä»æ¨¡æ¿/è™šæ‹Ÿæœºå…‹éš†è™šæ‹Ÿæœºå¹¶åº”ç”¨è‡ªå®šä¹‰è§„èŒƒï¼ˆCustomizationSpecï¼‰
    """
    template = pchelper.get_obj(content, [vim.VirtualMachine], template_name)
    if template is None:
        print(f"æœªæ‰¾åˆ°è™šæ‹Ÿæœº{template}")
        return
    # è·å–æ•°æ®ä¸­å¿ƒã€æ–‡ä»¶å¤¹ã€æ•°æ®å­˜å‚¨ã€é›†ç¾¤å’Œèµ„æºæ± ç­‰ä¿¡æ¯
    datacenter = pchelper.get_obj(content, [vim.Datacenter], datacenter_name)
    if vm_folder:
        destfolder = pchelper.search_for_obj(content, [vim.Folder], vm_folder)
    else:
        destfolder = datacenter.vmFolder

    if datastore_name:
        datastore = pchelper.search_for_obj(content, [vim.Datastore], datastore_name)
    else:
        datastore = pchelper.get_obj(content, [vim.Datastore], template.datastore[0].info.name)

    # è·å–é›†ç¾¤å’Œèµ„æºæ± 
    cluster = pchelper.search_for_obj(content, [vim.ClusterComputeResource], cluster_name)
    if not cluster:
        clusters = pchelper.get_all_obj(content, [vim.ResourcePool])
        cluster = list(clusters)[0]

    if resource_pool:
        resource_pool = pchelper.search_for_obj(content, [vim.ResourcePool], resource_pool)
    else:
        resource_pool = cluster.resourcePool

    # è®¾ç½®å…‹éš†è§„æ ¼
    relospec = vim.vm.RelocateSpec()
    relospec.datastore = datastore
    relospec.pool = resource_pool
    # æ­£ç¡®è®¾ç½®é…ç½®å‚æ•°
    clonespec = vim.vm.CloneSpec()
    vmconf = vim.vm.ConfigSpec()
    vmconf.numCPUs = cpu
    vmconf.numCoresPerSocket = cpu  # å¯é€‰ï¼šæ¯ä¸ª socket çš„æ ¸æ•°
    vmconf.memoryMB = memory * 1024  # å•ä½ MBï¼Œä¸éœ€è¦ä¹˜ 1024

    # è·å–æ¨¡æ¿çš„ç¬¬ä¸€ä¸ªç½‘å¡ï¼Œä¿®æ”¹è¿æ¥çŠ¶æ€
    nic_device = None
    for device in template.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if nic_device:
        nic_spec = vim.vm.device.VirtualDeviceSpec()
        nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        nic_spec.device = nic_device

        # å¼ºåˆ¶è®¾ç½®è¿æ¥å±æ€§
        nic_spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
        nic_spec.device.connectable.startConnected = True
        nic_spec.device.connectable.allowGuestControl = True
        nic_spec.device.connectable.connected = True

        vmconf.deviceChange = [nic_spec]  # åŠ å…¥è®¾å¤‡å˜æ›´
    clonespec.config = vmconf

    clonespec.location = relospec
    clonespec.powerOn = power_on
    clonespec.customization = customization_spec  # åœ¨å…‹éš†è§„èŒƒä¸­åº”ç”¨è‡ªå®šä¹‰è§„èŒƒ

    print(f"æ­£åœ¨ä»æ¨¡æ¿ {template_name} å…‹éš†è™šæ‹Ÿæœº {vm_name}...")
    task = template.Clone(folder=destfolder, name=vm_name, spec=clonespec)
    try:
        wait_for_task(task)
        print(f"è™šæ‹Ÿæœº {vm_name} å…‹éš†å®Œæˆå¹¶åº”ç”¨äº†è‡ªå®šä¹‰è§„èŒƒ")
        return pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    except Exception as e:
        raise RuntimeError(f"å…‹éš†å¤±è´¥: {str(e)}")


def power_vm(vm_name, status):
    """å¯åŠ¨è™šæ‹Ÿæœº"""
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        print("æœªæ‰¾åˆ°è™šæ‹Ÿæœº")
        return
    if status == "on":
        print("æ­£åœ¨å¯åŠ¨è™šæ‹Ÿæœº %s..." % vm.name)
        task = vm.PowerOn()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            print("å¯åŠ¨ä¸­...")
            time.sleep(1)
    elif status == "off":
        print("æ­£åœ¨å…³é—­è™šæ‹Ÿæœº %s..." % vm.name)
        task = vm.PowerOff()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            print("å…³é—­ä¸­...")
            time.sleep(1)

    if task.info.state == vim.TaskInfo.State.success:
        print("è™šæ‹Ÿæœº %s å·²ç»å¯åŠ¨ã€‚" % vm.name)
    else:
        print("å¯åŠ¨è™šæ‹Ÿæœºå¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯ï¼š%s" % task.info.error.localizedMessage)


def add_disk(vm_name, disk_size, disk_type):
    """
    å‘è™šæ‹Ÿæœºæ·»åŠ ç¡¬ç›˜
    """
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        print("æœªæ‰¾åˆ°è™šæ‹Ÿæœº")
        return
    spec = vim.vm.ConfigSpec()
    # è·å–è™šæ‹Ÿæœºä¸Šçš„æ‰€æœ‰ç£ç›˜ï¼Œè®¾ç½®ä¸‹ä¸€ä¸ªå¯ç”¨çš„ unit_number
    unit_number = 0
    controller = None
    for device in vm.config.hardware.device:
        if hasattr(device.backing, 'fileName'):
            unit_number = int(device.unitNumber) + 1
            # unit_number 7 ä¿ç•™ç»™ SCSI æ§åˆ¶å™¨
            if unit_number == 7:
                unit_number += 1
            if unit_number >= 16:
                print("æˆ‘ä»¬ä¸æ”¯æŒè¿™ä¹ˆå¤šç£ç›˜")
                return -1
        if isinstance(device, vim.vm.device.VirtualSCSIController):
            controller = device
    if controller is None:
        print("æœªæ‰¾åˆ°ç£ç›˜ SCSI æ§åˆ¶å™¨ï¼")
        return -1
    # åœ¨æ­¤å¤„æ·»åŠ ç£ç›˜
    dev_changes = []
    new_disk_kb = int(disk_size) * 1024 * 1024
    disk_spec = vim.vm.device.VirtualDeviceSpec()
    disk_spec.fileOperation = "create"
    disk_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
    disk_spec.device = vim.vm.device.VirtualDisk()
    disk_spec.device.backing = \
        vim.vm.device.VirtualDisk.FlatVer2BackingInfo()
    if disk_type == 'thin':
        disk_spec.device.backing.thinProvisioned = True
    disk_spec.device.backing.diskMode = 'persistent'
    disk_spec.device.unitNumber = unit_number
    disk_spec.device.capacityInKB = new_disk_kb
    disk_spec.device.controllerKey = controller.key
    dev_changes.append(disk_spec)
    spec.deviceChange = dev_changes
    WaitForTask(vm.ReconfigVM_Task(spec=spec))
    print("%sGB ç¡¬ç›˜å·²æ·»åŠ åˆ° %s" % (disk_size, vm.config.name))
    return 0


parser = cli.Parser()
parser.add_required_arguments(
    cli.Argument.VM_NAME,
    cli.Argument.DISK_SIZE,
    cli.Argument.TEMPLATE,
)
parser.add_custom_argument('--vm_ip', required=True, action='store', help='è™šæ‹Ÿæœºip 192.168.10.111')
parser.add_custom_argument('--vm_gateway', required=True, action='store', help='è™šæ‹Ÿæœºç½‘å…³ 192.168.10.1')
parser.add_custom_argument('--vm_netmask', required=True, action='store', help='è™šæ‹Ÿæœºæ©ç  24')
parser.add_custom_argument('--vm_dns', required=True, action='store', help='è™šæ‹Ÿæœºdns 192.168.105.12,192.168.105.11')
parser.add_custom_argument('--vm_vlan_name', required=True, action='store', help='è™šæ‹Ÿæœºçš„vlan vlan107')
parser.add_custom_argument('--vm_cpu', type=int, required=True, action='store', help='è™šæ‹Ÿæœºçš„cpu')
parser.add_custom_argument('--vm_memory', type=int, required=True, action='store', help='è™šæ‹Ÿæœºçš„memory Gb')
parser.add_custom_argument('--vm_note', required=True, action='store', help='è™šæ‹Ÿæœºçš„å¤‡æ³¨')
args = parser.get_args()


# from types import SimpleNamespace
#
# args = SimpleNamespace(
#     host="192.168.107.101",
#     user="administrator@vsphere.local",
#     password="P@ssw0rd",
#     vm_name="test-liyedong",
#     port=443,
#     disable_ssl_verification=True,  # æ–°å¢æ­¤å­—æ®µï¼Œé˜²æ­¢æŠ¥é”™
#     # template="debian12-template",
#     template="rocky9-template",
#     disk_size=10,
#     vm_ip="192.168.107.110",
#     vm_gateway="192.168.107.2",
#     vm_netmask="24",
#     vm_dns="114.114.114.114,8.8.8.8",
#     vm_vlan_name="vlan107",
#     vm_cpu=2,
#     vm_memory=2,
# )

si = service_instance.connect(args)

content = si.RetrieveContent()

# === è·å–ç›®æ ‡ç»„ä»¶ ===


# === è‡ªå®šä¹‰ IP/ç½‘å…³/DNS ç­‰ ===
# adapter = vim.vm.customization.AdapterMapping()
# adapter.adapter = vim.vm.customization.IPSettings()
# adapter.adapter.ip = vim.vm.customization.FixedIp()
# adapter.adapter.ip.ipAddress = args.vm_ip
# adapter.adapter.subnetMask = args.vm_netmask
# adapter.adapter.gateway = [args.vm_gateway]
# adapter.adapter.dnsDomain = "localdomain"
#
# dns_list = args.vm_dns.split(",")
#
# identity = vim.vm.customization.LinuxPrep()
# identity.hostName = vim.vm.customization.FixedName(name=args.vm_name)
# identity.domain = "localdomain"
# identity.timeZone = "Asia/Shanghai"
#
# global_ip = vim.vm.customization.GlobalIPSettings()
# global_ip.dnsServerList = dns_list
#
# custom_spec = vim.vm.customization.Specification()
# custom_spec.nicSettingMap = [adapter]
# custom_spec.identity = identity
# custom_spec.globalIPSettings = global_ip

# === å…‹éš†é…ç½® ===

# å…‹éš†è™šæ‹Ÿæœº
try:
    vm = clone_vm_with_customization(
        content,
        args.template,
        args.vm_name,
        'DC-A4-XM-ZD-DataCenter',
        None,
        'A4-XM-ZD-56.30-SATA-DS01',
        'DC-A4-XM-ZD-Cluster01',
        None,
        True,
        None,
        # custom_spec,
        None,
        args.vm_cpu,
        args.vm_memory
    )
    # vm = clone_vm_with_customization(
    #     content,
    #     args.template,
    #     args.vm_name,
    #     'Datacenter',
    #     None,
    #     'data',
    #     None,
    #     None,
    #     True,
    #     None,
    #     # custom_spec,
    #     None,
    #     args.vm_cpu,
    #     args.vm_memory
    # )
    print(f"è™šæ‹Ÿæœº {args.vm_name} åˆ›å»ºæˆåŠŸ")
except Exception as e:
    print(f"é”™è¯¯: {str(e)}")
# === æŒ‚è½½æ–°ç¡¬ç›˜ ===
add_disk(args.vm_name, args.disk_size, 'thin')

# æŒ‡å®švlan
update_nic_network(si, args.vm_name, args.vm_vlan_name)
vm_obj = pchelper.get_obj(content, [vim.VirtualMachine], args.vm_name)
if vm_obj is None:
    print("æœªæ‰¾åˆ°è™šæ‹Ÿæœº")
set_note(vm_obj, args.vm_note)
check_vm_tool(vm_obj)
time.sleep(5)
bash_script = fr'''
#!/bin/bash
exec > /root/customize_vm.log 2>&1
set -ex

hostnamectl set-hostname {args.vm_name}

OS_FAMILY=$(grep ^ID= /etc/os-release | cut -d= -f2 | tr -d '"')
INTERFACE=$(ip route | grep default | awk '{{print $5}}')
echo "$OS_FAMILY" >> /root/customize_vm.log
echo "$INTERFACE" >> /root/customize_vm.log
if [ "$OS_FAMILY" = "debian" ]; then
  # Debian - ä¿®æ”¹ /etc/network/interfaces
cat > /etc/network/interfaces <<ONEEOF
auto lo
iface lo inet loopback

auto $INTERFACE
iface $INTERFACE inet static
  address {args.vm_ip}
  netmask {args.vm_netmask}
  gateway {args.vm_gateway}
  dns-nameservers {args.vm_dns}
ONEEOF
  ifdown $INTERFACE || true
  ifup $INTERFACE

elif [ "$OS_FAMILY" = "ubuntu" ]; then
  # Ubuntu - ä½¿ç”¨ netplanï¼ˆ17.10+ï¼‰
cat > /etc/netplan/01-netcfg.yaml <<TWOEOF
network:
  version: 2
  renderer: networkd
  ethernets:
    $INTERFACE:
      dhcp4: no
      addresses:
        - {args.vm_ip}/{args.vm_netmask}
      gateway4: {args.vm_gateway}
      nameservers:
        addresses: [{args.vm_dns}]
TWOEOF
  netplan apply

# === RHEL / Rocky / AlmaLinux ç³»åˆ— ===
else

  nmcli con mod "$INTERFACE" ipv4.addresses {args.vm_ip}/{args.vm_netmask} 
  nmcli con mod "$INTERFACE" ipv4.gateway {args.vm_gateway} 
  nmcli con mod "$INTERFACE" ipv4.dns "{args.vm_dns}" 
  nmcli con mod "$INTERFACE" ipv4.method manual 
  nmcli con mod "$INTERFACE" connection.autoconnect yes 
  nmcli con down "$INTERFACE" || true
  nmcli con up "$INTERFACE"
fi

# === æŒ‚è½½æ•°æ®ç›˜éƒ¨åˆ† ===
if [ -b /dev/sdb ] && ! vgdisplay my_vg &>/dev/null; then
  echo "å¼€å§‹é…ç½® LVM æ•°æ®ç›˜ï¼š/dev/sdb -> /u01"
  # åˆ›å»ºç‰©ç†å·ï¼ˆPVï¼‰
  pvcreate /dev/sdb
  # åˆ›å»ºå·ç»„ï¼ˆVGï¼‰
  vgcreate my_vg /dev/sdb
  # åˆ›å»ºé€»è¾‘å·ï¼ˆLVï¼‰å ç”¨å…¨éƒ¨ç©ºé—´
  lvcreate -l 100%FREE -n my_lv my_vg
  # æ ¼å¼åŒ–ä¸º ext4 æ–‡ä»¶ç³»ç»Ÿ
  mkfs.ext4 /dev/my_vg/my_lv
  # åˆ›å»ºæŒ‚è½½ç‚¹ç›®å½•
  mkdir -p /u01
  # æ·»åŠ æŒ‚è½½ä¿¡æ¯åˆ° /etc/fstabï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
  grep -q '/u01' /etc/fstab || echo '/dev/my_vg/my_lv /u01 ext4 defaults 0 0' >> /etc/fstab
  # æŒ‚è½½æ‰€æœ‰æ–‡ä»¶ç³»ç»Ÿ
  mount -a
else
  echo "è·³è¿‡ LVM é…ç½®ï¼š/dev/sdb ä¸å­˜åœ¨æˆ–å·ç»„ my_vg å·²å­˜åœ¨"
fi
'''
upload_script_and_run_sync(si, vm_obj, bash_script,'/root/init.sh', "root", "P@ssw0rd")
#upload_script_and_run_sync(si, vm_obj, bash_script,'/root/init.sh', "root", "root")
# time.sleep(30)
# power_vm(args.vm_name, "off")
# time.sleep(3)
# power_vm(args.vm_name, "on")
# time.sleep(60)
# check_vm_tool(vm_obj)
# run_script_in_vm(si, vm_obj, r'/bin/bash /root/init.sh', "root", "root")


"""
pyinstaller -F --add-data "tools;tools" --hidden-import pyVmomi --hidden-import pyVim --hidden-import pyVim.connect --hidden-import openpyxl --hidden-import gooey create_cus_rule_by_bash.py
.\create_cus_rule.exe `
-s 192.168.xxx.8 `
-u xxx@xxxx.org `
-p xxxx `
-v test-liyedong `
-nossl `
--template rhelmini8.10-template-100G  `
--disk-size 50 `
--vm_ip 192.168.107.100 `
--vm_gateway 192.168.107.1 `
--vm_netmask 24 `
--vm_dns 192.168.105.12,192.168.105.11 `
--vm_vlan_name vlan107 `
--vm_cpu 10 `
--vm_memory 10 
--vm_disk_type ext4 #è¿˜æœªå¼€å‘
"""

```

å®ç°windowsçš„è‡ªåŠ¨å…‹éš†åˆ›å»ºï¼Œå¹¶ä¸”å®ç°sidæ›´æ–°ï¼Œipè‡ªåŠ¨é…ç½®ï¼Œç£ç›˜è‡ªåŠ¨åˆ†åŒºï¼Œæ¨¡æ¿éœ€è¦æŠŠé©±åŠ¨å™¨ç›˜ç¬¦ä¿®æ”¹æˆDç›˜ï¼Œæµ‹è¯•é€šè¿‡2016ã€2019

```python
import time

from pyVmomi import vim
from tools import cli, service_instance, pchelper
from pyVim.task import WaitForTask


def wait_for_task(task):
    """ ç­‰å¾… vCenter ä»»åŠ¡å®Œæˆ """
    task_done = False
    while not task_done:
        if task.info.state == 'success':
            return task.info.result
        if task.info.state == 'error':
            print("å‡ºç°é”™è¯¯")
            print(task.info.error)
            task_done = True

def set_note(vm, annotation):
    # åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿæœºé…ç½®è§„èŒƒï¼Œå¹¶è®¾ç½®å¤‡æ³¨
    spec = vim.vm.ConfigSpec()
    spec.annotation = annotation

    # æäº¤é…ç½®ä»»åŠ¡
    task = vm.ReconfigVM_Task(spec)
    while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
        continue

    print(f"å·²æ›´æ–°è™šæ‹Ÿæœº{vm.name}çš„å¤‡æ³¨ä¸ºï¼š{annotation}")

def run_script_in_vm(si, vm, script_text, username, password, os_type='linux'):
    """
    åœ¨è™šæ‹Ÿæœºä¸­é€šè¿‡ VMware Tools æ‰§è¡Œè„šæœ¬ï¼Œæ”¯æŒ Linux å’Œ Windows
    :param si: æœåŠ¡å®ä¾‹
    :param vm: è™šæ‹Ÿæœºå¯¹è±¡
    :param script_text: éœ€è¦æ‰§è¡Œçš„è„šæœ¬å†…å®¹
    :param username: è™šæ‹Ÿæœºçš„ç”¨æˆ·å
    :param password: è™šæ‹Ÿæœºçš„å¯†ç 
    :param os_type: è™šæ‹Ÿæœºæ“ä½œç³»ç»Ÿç±»å‹ï¼Œ'linux' æˆ– 'windows'
    """
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)

    pm = si.content.guestOperationsManager.processManager

    if os_type.lower() == 'linux':
        # Linux ç”¨ /bin/bash æ‰§è¡Œ
        program_path = '/bin/bash'
        arguments = f'-c "{script_text}"'
    elif os_type.lower() == 'windows':
        # Windows ç”¨ cmd.exe /c æ‰§è¡Œï¼Œè„šæœ¬å†™æˆä¸€æ¡å‘½ä»¤
        program_path = r'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe'
        # Windows cmd æ‰§è¡Œè„šæœ¬æ—¶éœ€è¦è½¬ä¹‰åŒå¼•å·ï¼Œä¸” /c åæ¥å‘½ä»¤
        # è¿™é‡Œç”¨ä¸€æ¡å‘½ä»¤æ‰§è¡Œï¼Œå¦‚æœæ˜¯å¤šè¡Œå¤æ‚è„šæœ¬å»ºè®®å…ˆä¸Šä¼ è„šæœ¬æ–‡ä»¶å†æ‰§è¡Œ
        # ç›´æ¥ä¼ è„šæœ¬å†…å®¹æ—¶å»ºè®®å†™æˆå•æ¡å‘½ä»¤æˆ–ç”¨ & è¿æ¥å¤šä¸ªå‘½ä»¤
        # escaped_script = script_text.replace('"', '\\"')
        arguments = fr'powershell.exe -Command {script_text}'
        print(fr"æ‰§è¡Œ{program_path} {arguments}")
    else:
        raise ValueError(f"ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿç±»å‹: {os_type}")

    ps = vim.vm.guest.ProcessManager.ProgramSpec(programPath=program_path, arguments=arguments)

    pid = pm.StartProgramInGuest(vm, creds, ps)
    print(f"å·²åœ¨è™šæ‹Ÿæœº {vm.name} ä¸­å¯åŠ¨è¿›ç¨‹ï¼ŒPID: {pid}")
    return pid

def update_nic_network(si, vm_name, new_network_name):
    """
    ä¿®æ”¹è™šæ‹Ÿæœºç¬¬ä¸€å—ç½‘å¡è¿æ¥çš„ç½‘ç»œæ ‡ç­¾ï¼ˆç«¯å£ç»„ï¼‰
    :param si: vSphere service instance
    :param vm: è™šæ‹Ÿæœºå¯¹è±¡
    :param new_network_name: æ–°çš„ç½‘ç»œæ ‡ç­¾ï¼ˆç«¯å£ç»„åç§°ï¼‰
    """
    content = si.RetrieveContent()
    new_network = pchelper.get_obj(content, [vim.Network], new_network_name)
    if not new_network:
        raise RuntimeError(f"æ‰¾ä¸åˆ°ç½‘ç»œæ ‡ç­¾ï¼š{new_network_name}")
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        raise RuntimeError(f"æœªæ‰¾åˆ°è™šæ‹Ÿæœº{vm_name}")
    # æŸ¥æ‰¾ç°æœ‰çš„ç½‘å¡è®¾å¤‡ï¼ˆä»¥ç¬¬ä¸€å—ä¸ºä¾‹ï¼‰
    nic_device = None
    for device in vm.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if not nic_device:
        raise RuntimeError("æœªæ‰¾åˆ°è™šæ‹Ÿæœºç½‘å¡")

    # ä¿®æ”¹ backingï¼ˆæ ‡å‡†ç«¯å£ç»„æˆ–åˆ†å¸ƒå¼äº¤æ¢æœºï¼‰
    if isinstance(new_network, vim.dvs.DistributedVirtualPortgroup):
        port = vim.dvs.PortConnection()
        port.portgroupKey = new_network.key
        port.switchUuid = new_network.config.distributedVirtualSwitch.uuid

        nic_device.backing = vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo()
        nic_device.backing.port = port
    else:
        nic_device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
        nic_device.backing.deviceName = new_network_name
        nic_device.backing.network = new_network

    # âœ… å¼€å¯ç½‘å¡è¿æ¥å¹¶å‹¾é€‰â€œå¼€æœºæ—¶è¿æ¥â€
    nic_device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
    nic_device.connectable.startConnected = True  # å¼€æœºè‡ªè¿æ¥
    nic_device.connectable.allowGuestControl = True
    nic_device.connectable.connected = True

    # æ„é€ é…ç½® spec
    nic_spec = vim.vm.device.VirtualDeviceSpec()
    nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    nic_spec.device = nic_device

    spec = vim.vm.ConfigSpec()
    spec.deviceChange = [nic_spec]


    # åº”ç”¨é…ç½®
    task = vm.ReconfigVM_Task(spec=spec)
    wait_for_task(task)
    print(f"å·²ä¿®æ”¹ç½‘å¡è¿æ¥åˆ°ç½‘ç»œï¼š{new_network_name}")


def clone_vm_with_customization(content, template_name, vm_name, datacenter_name, vm_folder, datastore_name,
                                cluster_name, resource_pool, power_on, datastorecluster_name, customization_spec,
                                cpu, memory):
    """
    ä»æ¨¡æ¿/è™šæ‹Ÿæœºå…‹éš†è™šæ‹Ÿæœºå¹¶åº”ç”¨è‡ªå®šä¹‰è§„èŒƒï¼ˆCustomizationSpecï¼‰
    """
    template = pchelper.get_obj(content, [vim.VirtualMachine], template_name)
    if template is None:
        print(f"æœªæ‰¾åˆ°è™šæ‹Ÿæœº{template}")
        return
    # è·å–æ•°æ®ä¸­å¿ƒã€æ–‡ä»¶å¤¹ã€æ•°æ®å­˜å‚¨ã€é›†ç¾¤å’Œèµ„æºæ± ç­‰ä¿¡æ¯
    datacenter = pchelper.get_obj(content, [vim.Datacenter], datacenter_name)
    if vm_folder:
        destfolder = pchelper.search_for_obj(content, [vim.Folder], vm_folder)
    else:
        destfolder = datacenter.vmFolder

    if datastore_name:
        datastore = pchelper.search_for_obj(content, [vim.Datastore], datastore_name)
    else:
        datastore = pchelper.get_obj(content, [vim.Datastore], template.datastore[0].info.name)

    # è·å–é›†ç¾¤å’Œèµ„æºæ± 
    cluster = pchelper.search_for_obj(content, [vim.ClusterComputeResource], cluster_name)
    if not cluster:
        clusters = pchelper.get_all_obj(content, [vim.ResourcePool])
        cluster = list(clusters)[0]

    if resource_pool:
        resource_pool = pchelper.search_for_obj(content, [vim.ResourcePool], resource_pool)
    else:
        resource_pool = cluster.resourcePool

    # è®¾ç½®å…‹éš†è§„æ ¼
    relospec = vim.vm.RelocateSpec()
    relospec.datastore = datastore
    relospec.pool = resource_pool
    # æ­£ç¡®è®¾ç½®é…ç½®å‚æ•°
    clonespec = vim.vm.CloneSpec()
    vmconf = vim.vm.ConfigSpec()
    vmconf.numCPUs = cpu
    vmconf.numCoresPerSocket = cpu  # å¯é€‰ï¼šæ¯ä¸ª socket çš„æ ¸æ•°
    vmconf.memoryMB = memory * 1024  # å•ä½ MBï¼Œä¸éœ€è¦ä¹˜ 1024

    # è·å–æ¨¡æ¿çš„ç¬¬ä¸€ä¸ªç½‘å¡ï¼Œä¿®æ”¹è¿æ¥çŠ¶æ€
    nic_device = None
    for device in template.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if nic_device:
        nic_spec = vim.vm.device.VirtualDeviceSpec()
        nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        nic_spec.device = nic_device

        # å¼ºåˆ¶è®¾ç½®è¿æ¥å±æ€§
        nic_spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
        nic_spec.device.connectable.startConnected = True
        nic_spec.device.connectable.allowGuestControl = True
        nic_spec.device.connectable.connected = True

        vmconf.deviceChange = [nic_spec]  # åŠ å…¥è®¾å¤‡å˜æ›´
    clonespec.config = vmconf

    clonespec.location = relospec
    clonespec.powerOn = power_on
    clonespec.customization = customization_spec  # åœ¨å…‹éš†è§„èŒƒä¸­åº”ç”¨è‡ªå®šä¹‰è§„èŒƒ

    print(f"æ­£åœ¨ä»æ¨¡æ¿ {template_name} å…‹éš†è™šæ‹Ÿæœº {vm_name}...")
    task = template.Clone(folder=destfolder, name=vm_name, spec=clonespec)
    try:
        wait_for_task(task)
        print(f"è™šæ‹Ÿæœº {vm_name} å…‹éš†å®Œæˆå¹¶åº”ç”¨äº†è‡ªå®šä¹‰è§„èŒƒ")
        return pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    except Exception as e:
        raise RuntimeError(f"å…‹éš†å¤±è´¥: {str(e)}")


def add_disk(vm_name, disk_size, disk_type):
    """
    å‘è™šæ‹Ÿæœºæ·»åŠ ç¡¬ç›˜
    """
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        print("æœªæ‰¾åˆ°è™šæ‹Ÿæœº")
        return
    spec = vim.vm.ConfigSpec()
    # è·å–è™šæ‹Ÿæœºä¸Šçš„æ‰€æœ‰ç£ç›˜ï¼Œè®¾ç½®ä¸‹ä¸€ä¸ªå¯ç”¨çš„ unit_number
    unit_number = 0
    controller = None
    for device in vm.config.hardware.device:
        if hasattr(device.backing, 'fileName'):
            unit_number = int(device.unitNumber) + 1
            # unit_number 7 ä¿ç•™ç»™ SCSI æ§åˆ¶å™¨
            if unit_number == 7:
                unit_number += 1
            if unit_number >= 16:
                print("æˆ‘ä»¬ä¸æ”¯æŒè¿™ä¹ˆå¤šç£ç›˜")
                return -1
        if isinstance(device, vim.vm.device.VirtualSCSIController):
            controller = device
    if controller is None:
        print("æœªæ‰¾åˆ°ç£ç›˜ SCSI æ§åˆ¶å™¨ï¼")
        return -1
    # åœ¨æ­¤å¤„æ·»åŠ ç£ç›˜
    dev_changes = []
    new_disk_kb = int(disk_size) * 1024 * 1024
    disk_spec = vim.vm.device.VirtualDeviceSpec()
    disk_spec.fileOperation = "create"
    disk_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
    disk_spec.device = vim.vm.device.VirtualDisk()
    disk_spec.device.backing = \
        vim.vm.device.VirtualDisk.FlatVer2BackingInfo()
    if disk_type == 'thin':
        disk_spec.device.backing.thinProvisioned = True
    disk_spec.device.backing.diskMode = 'persistent'
    disk_spec.device.unitNumber = unit_number
    disk_spec.device.capacityInKB = new_disk_kb
    disk_spec.device.controllerKey = controller.key
    dev_changes.append(disk_spec)
    spec.deviceChange = dev_changes
    WaitForTask(vm.ReconfigVM_Task(spec=spec))
    print("%sGB ç¡¬ç›˜å·²æ·»åŠ åˆ° %s" % (disk_size, vm.config.name))
    return 0


parser = cli.Parser()
parser.add_required_arguments(
    cli.Argument.VM_NAME,
    cli.Argument.DISK_SIZE,
    cli.Argument.TEMPLATE,
)
parser.add_custom_argument('--vm_ip', required=True, action='store', help='è™šæ‹Ÿæœºip 192.168.10.111')
parser.add_custom_argument('--vm_gateway', required=True, action='store', help='è™šæ‹Ÿæœºç½‘å…³ 192.168.10.1')
parser.add_custom_argument('--vm_netmask', required=True, action='store', help='è™šæ‹Ÿæœºæ©ç  255.255.255.0')
parser.add_custom_argument('--vm_dns', required=True, action='store', help='è™šæ‹Ÿæœºdns 192.168.105.12,192.168.105.11')
parser.add_custom_argument('--vm_vlan_name', required=True, action='store', help='è™šæ‹Ÿæœºçš„vlan vlan107')
parser.add_custom_argument('--vm_cpu', type=int, required=True, action='store', help='è™šæ‹Ÿæœºçš„cpu')
parser.add_custom_argument('--vm_memory', type=int, required=True, action='store', help='è™šæ‹Ÿæœºçš„memory Gb')
parser.add_custom_argument('--vm_note', required=True, action='store', help='è™šæ‹Ÿæœºçš„å¤‡æ³¨')

args = parser.get_args()
si = service_instance.connect(args)

content = si.RetrieveContent()

# === è·å–ç›®æ ‡ç»„ä»¶ ===


# === è‡ªå®šä¹‰ IP/ç½‘å…³/DNS ç­‰ ===
from pyVmomi import vim

def create_windows_customization_spec(vm_name: str,
                                      ip: str,
                                      subnet_mask: str,
                                      gateway: list,
                                      dns_servers: list,
                                      domain: str = None,
                                      domain_admin: str = None,
                                      domain_admin_password: str = None,
                                      admin_password: str = None,
                                      time_zone: int = 210  # ä¸­å›½æ ‡å‡†æ—¶é—´
                                      ) -> vim.vm.customization.Specification:
    """
    åˆ›å»º Windows è‡ªå®šä¹‰è§„èŒƒï¼ˆCustomizationSpecï¼‰
    """
    # è®¾ç½®ç½‘ç»œé€‚é…å™¨æ˜ å°„å’Œ IP é…ç½®
    adapter_map = vim.vm.customization.AdapterMapping()
    ip_settings = vim.vm.customization.IPSettings()
    ip_settings.ip = vim.vm.customization.FixedIp(ipAddress=ip)
    ip_settings.subnetMask = subnet_mask
    ip_settings.gateway = gateway
    ip_settings.dnsServerList = dns_servers
    adapter_map.adapter = ip_settings

    # è®¾ç½® Sysprep èº«ä»½ä¿¡æ¯
    identity = vim.vm.customization.Sysprep()

    # è®¾ç½® userDataï¼ˆåŒ…æ‹¬è®¡ç®—æœºåã€ç”¨æˆ·åã€ç»„ç»‡ï¼‰
    identity.userData = vim.vm.customization.UserData()
    identity.userData.computerName = vim.vm.customization.FixedName(name=vm_name)
    identity.userData.fullName = "Administrator"
    identity.userData.orgName = "MyCompany"

    # è®¾ç½® GUI è‡ªåŠ¨åŒ–ï¼ˆç™»å½•è®¾ç½®å’Œæ—¶åŒºï¼‰
    if admin_password is None:
        admin_password = "P@ssw0rd"

    gui_pass = vim.vm.customization.Password()
    gui_pass.plainText = True
    gui_pass.value = admin_password

    identity.guiUnattended = vim.vm.customization.GuiUnattended()
    identity.guiUnattended.autoLogon = False
    identity.guiUnattended.password = gui_pass
    identity.guiUnattended.timeZone = time_zone

    # è®¾ç½®åŸŸæˆ–å·¥ä½œç»„
    identity.identification = vim.vm.customization.Identification()
    if domain and domain_admin and domain_admin_password:
        domain_pass = vim.vm.customization.Password()
        domain_pass.plainText = True
        domain_pass.value = domain_admin_password

        identity.identification.domain = domain
        identity.identification.domainAdmin = domain_admin
        identity.identification.domainAdminPassword = domain_pass
    else:
        identity.identification.joinWorkgroup = "WORKGROUP"

    # å…¨å±€ DNS è®¾ç½®
    global_ip = vim.vm.customization.GlobalIPSettings()
    global_ip.dnsServerList = dns_servers

    # ç»„è£…è§„èŒƒå¯¹è±¡
    custom_spec = vim.vm.customization.Specification()
    custom_spec.nicSettingMap = [adapter_map]
    custom_spec.identity = identity
    custom_spec.globalIPSettings = global_ip

    return custom_spec
def upload_and_run_powershell_script(si, vm, script_text, remote_path, log_path, username, password, timeout=300):
    from pyVmomi import vim
    import base64
    import time

    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    pm = si.content.guestOperationsManager.processManager

    # 1. ç¼–ç  PowerShell è„šæœ¬ä¸º Base64
    encoded_script = base64.b64encode(script_text.encode('utf-8')).decode('utf-8')

    # 2. ä½¿ç”¨ Set-Content å†™å…¥è§£ç è„šæœ¬æ–‡ä»¶ï¼ˆæ›´å¯é ï¼‰
    # æ³¨æ„è½¬ä¹‰åŒå¼•å·å’ŒåµŒå¥—ç»“æ„
    write_script_cmd = (
        f'powershell.exe -Command "'
        f'$b64 = \\"{encoded_script}\\"; '
        f'$bytes = [Convert]::FromBase64String($b64); '
        f'$text = [System.Text.Encoding]::UTF8.GetString($bytes); '
        f'Set-Content -Path \\"{remote_path}\\" -Value $text -Encoding UTF8"'
    )

    # write_script_cmd = (
    #     f"powershell.exe -Command "
    #     f"echo '{script_text}' > {remote_path}'"
    # )
    # 3. æ‰§è¡Œ .ps1 è„šæœ¬å¹¶é‡å®šå‘è¾“å‡º
    run_script_cmd = f'powershell.exe -ExecutionPolicy Bypass -File "{remote_path}" > "{log_path}" 2>&1'

    # 4. æ‹¼æ¥ä¸ºå®Œæ•´çš„ cmd.exe å‘½ä»¤
    full_cmd = f'{write_script_cmd} && {run_script_cmd}'

    spec = vim.vm.guest.ProcessManager.ProgramSpec(
        programPath="cmd.exe",
        arguments=f"/c {full_cmd}"
    )

    pid = pm.StartProgramInGuest(vm, creds, spec)
    print(f"æ‰§è¡Œè¿›ç¨‹ PID: {pid}")

    # ç­‰å¾…æ‰§è¡Œç»“æŸ
    start_time = time.time()
    while True:
        proc = pm.ListProcessesInGuest(vm, creds, [pid])[0]
        if proc.exitCode is not None:
            print(f"è„šæœ¬æ‰§è¡Œç»“æŸï¼Œé€€å‡ºç : {proc.exitCode}")
            return proc.exitCode
        if time.time() - start_time > timeout:
            print("æ‰§è¡Œè¶…æ—¶")
            return None
        time.sleep(2)

def check_vm_tool(vm, timeout=30):
    temp = 0
    while True:
        time.sleep(1)
        temp = temp + 1
        try:
            print(f"toolçŠ¶æ€æ£€æŸ¥ä¸­ç¬¬{temp}æ¬¡")
            if vm.guest.toolsStatus == "toolsOk":
                break
        except Exception as e:
            print(f"é”™è¯¯{e}")
            break
        if temp == timeout:
            print(f"è¶…æ—¶")
            break
def cidr_to_netmask(cidr):
    cidr = int(cidr)  # <== æ·»åŠ è¿™ä¸€è¡Œ
    bits = 0xffffffff ^ (1 << 32 - cidr) - 1
    return "{}.{}.{}.{}".format((bits >> 24) & 0xff, (bits >> 16) & 0xff, (bits >> 8) & 0xff, bits & 0xff)


# ç¤ºä¾‹ç”¨æ³•
subnet_mask = cidr_to_netmask(args.vm_netmask)  # 24 => '255.255.255.0'


dns_list = args.vm_dns.split(',')  # æ¯”å¦‚ "192.168.105.12,192.168.105.11"
# === å…‹éš†é…ç½® ===
win_custom_spec = create_windows_customization_spec(
    vm_name=args.vm_name,
    ip=args.vm_ip,
    subnet_mask=subnet_mask,
    gateway=[args.vm_gateway],
    dns_servers=dns_list,
    domain=None,
    domain_admin=None,
    domain_admin_password=None,
    admin_password=None,
    time_zone=210
)
# å…‹éš†è™šæ‹Ÿæœº
try:
    vm = clone_vm_with_customization(
        content,
        args.template,
        args.vm_name,
        'DC-A4-XM-ZD-DataCenter',
        None,
        'A4-XM-ZD-56.30-SATA-DS01',
        'DC-A4-XM-ZD-Cluster01',
        None,
        True,
        None,
        win_custom_spec,
        args.vm_cpu,
        args.vm_memory
    )
    print(f"è™šæ‹Ÿæœº {args.vm_name} åˆ›å»ºæˆåŠŸ")
except Exception as e:
    print(f"é”™è¯¯: {str(e)}")
# === æŒ‚è½½æ–°ç¡¬ç›˜ ===
add_disk(args.vm_name, args.disk_size, 'thin')

# æŒ‡å®švlan
update_nic_network(si, args.vm_name, args.vm_vlan_name)

time.sleep(120)



script = (
    'Get-Disk | Where-Object PartitionStyle -Eq "RAW" | '
    'Initialize-Disk -PartitionStyle MBR -PassThru | '
    'New-Partition -UseMaximumSize -AssignDriveLetter | '
    'Format-Volume -FileSystem NTFS -NewFileSystemLabel "DataDisk" -Confirm:$false'
)

vm_obj = pchelper.get_obj(content, [vim.VirtualMachine], args.vm_name)
if vm_obj is None:
    print("æœªæ‰¾åˆ°è™šæ‹Ÿæœº")
set_note(vm_obj, args.vm_note)
check_vm_tool(vm_obj)
#run_script_in_vm(si, vm_obj, script, username='Administrator', password='P@ssw0rd', os_type='windows')
upload_and_run_powershell_script(si,vm_obj,script,"c:/Windows/Temp/temp.ps1","c:/logs.txt","Administrator","P@ssw0rd")

```

```python
# VMware vSphere Python SDK Community Samples Addons
# Copyright (c) 2014-2021 VMware, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
This module implements simple helper functions for python samples
"""

# import argparse
# self._parser = argparse.ArgumentParser(description='ä¸ vCenter é€šä¿¡çš„å‚æ•°')
from gooey import GooeyParser
import getpass

__author__ = "VMware, Inc."


class Parser:
    """
    Samples specific argument parser.
    Wraps argparse to ease the setup of argument requirements for the samples.

    Example:
        parser = cli.Parser()
        parser.add_required_arguments(cli.Argument.VM_NAME)
        parser.add_optional_arguments(cli.Argument.DATACENTER_NAME, cli.Argument.NIC_NAME)
        parser.add_custom_argument(
            '--disk-number', required=True, help='Disk number to change mode.')
        args = parser.get_args()
    """

    def __init__(self):
        """
        Defines two arguments groups.
        One for the standard arguments and one for sample specific arguments.
        The standard group cannot be extended.
        """
        # import argparse
        # self._parser = argparse.ArgumentParser(description='ä¸ vCenter é€šä¿¡çš„å‚æ•°')
        from gooey import GooeyParser
        self._parser = GooeyParser(description='ä¸ vCenter é€šä¿¡çš„å‚æ•°')
        self._standard_args_group = self._parser.add_argument_group('æ ‡å‡†å‚æ•°')
        self._specific_args_group = self._parser.add_argument_group('æ ·æœ¬ç‰¹å®šå‚æ•°')

        # because -h is reserved for 'help' we use -s for service
        self._standard_args_group.add_argument('-s', '--host',
                                               required=True,
                                               action='store',
                                               help='è¦è¿æ¥çš„ vSphere æœåŠ¡åœ°å€')

        # because we want -p for password, we use -o for port
        self._standard_args_group.add_argument('-o', '--port',
                                               type=int,
                                               default=443,
                                               action='store',
                                               help='è¿æ¥åˆ° vSphere æœåŠ¡æ—¶ä½¿ç”¨çš„ç«¯å£å·')

        self._standard_args_group.add_argument('-u', '--user',
                                               required=True,
                                               action='store',
                                               help='è¿æ¥ä¸»æœºæ—¶ä½¿ç”¨çš„ç”¨æˆ·å')

        self._standard_args_group.add_argument('-p', '--password',
                                               required=False,
                                               action='store',
                                               widget='PasswordField',
                                               help='è¿æ¥ä¸»æœºæ—¶ä½¿ç”¨çš„å¯†ç ')

        self._standard_args_group.add_argument('-nossl', '--disable-ssl-verification',
                                               required=False,
                                               action='store_true',
                                               help='ç¦ç”¨ SSL ä¸»æœºè¯ä¹¦éªŒè¯')

    def get_args(self):
        """
        Supports the command-line arguments needed to form a connection to vSphere.
        """
        args = self._parser.parse_args()
        return self._prompt_for_password(args)

    def _add_sample_specific_arguments(self, is_required: bool, *args):
        """
        Add an argument to the "sample specific arguments" group
        Requires a predefined argument from the Argument class.
        """
        for arg in args:
            name_or_flags = arg["name_or_flags"]
            options = arg["options"]
            options["required"] = is_required
            self._specific_args_group.add_argument(*name_or_flags, **options)

    def add_required_arguments(self, *args):
        """
        Add a required argument to the "sample specific arguments" group
        Requires a predefined argument from the Argument class.
        """
        self._add_sample_specific_arguments(True, *args)

    def add_optional_arguments(self, *args):
        """
        Add an optional argument to the "sample specific arguments" group.
        Requires a predefined argument from the Argument class.
        """
        self._add_sample_specific_arguments(False, *args)

    def add_custom_argument(self, *name_or_flags, **options):
        """
        Uses ArgumentParser.add_argument() to add a full definition of a command line argument
        to the "sample specific arguments" group.
        https://docs.python.org/3/library/argparse.html#the-add-argument-method
        """
        self._specific_args_group.add_argument(*name_or_flags, **options)

    def set_epilog(self, epilog):
        """
        Text to display after the argument help
        """
        self._parser.epilog = epilog

    def _prompt_for_password(self, args):
        """
        if no password is specified on the command line, prompt for it
        """
        if not args.password:
            args.password = getpass.getpass(
                prompt='"--password" not provided! Please enter password for host %s and user %s: '
                       % (args.host, args.user))
        return args


class Argument:
    """
    Predefined arguments to use in the Parser

    Example:
        parser = cli.Parser()
        parser.add_optional_arguments(cli.Argument.VM_NAME)
        parser.add_optional_arguments(cli.Argument.DATACENTER_NAME, cli.Argument.NIC_NAME)
    """

    def __init__(self):
        pass

    UUID = {
        'name_or_flags': ['--uuid'],
        'options': {'action': 'store', 'help': 'UUID of an entity (VirtualMachine or HostSystem)'}
    }
    VM_NAME = {
        'name_or_flags': ['-v', '--vm-name'],
        'options': {'action': 'store', 'help': 'Name of the vm'}
    }
    VM_IP = {
        'name_or_flags': ['--vm-ip'],
        'options': {'action': 'store', 'help': 'IP of the vm'}
    }
    VM_MAC = {
        'name_or_flags': ['-mac', '--vm-mac'],
        'options': {'action': 'store', 'help': 'Mac address of the VM'}
    }
    VM_USER = {
        'name_or_flags': ['--vm-user'],
        'options': {'action': 'store', 'help': 'virtual machine user name'}
    }
    VM_PASS = {
        'name_or_flags': ['--vm-password'],
        'options': {'action': 'store', 'help': 'virtual machine password'}
    }
    ESX_NAME = {
        'name_or_flags': ['-e', '--esx-name'],
        'options': {'action': 'store', 'help': 'Esx name'}
    }
    ESX_IP = {
        'name_or_flags': ['--esx-ip'],
        'options': {'action': 'store', 'help': 'Esx ip'}
    }
    ESX_NAME_REGEX = {
        'name_or_flags': ['--esx-name-regex'],
        'options': {'action': 'store', 'help': 'Esx name regex'}
    }
    DNS_NAME = {
        'name_or_flags': ['--dns-name'],
        'options': {'action': 'store', 'help': 'DNS name'}
    }
    NAME = {
        'name_or_flags': ['-n', '--name'],
        'options': {'action': 'store', 'help': 'Name of the entity'}
    }
    NEW_NAME = {
        'name_or_flags': ['-r', '--new-name'],
        'options': {'action': 'store', 'help': 'New name of the entity.'}
    }
    DATACENTER_NAME = {
        'name_or_flags': ['--datacenter-name'],
        'options': {'action': 'store', 'help': 'Datacenter name'}
    }
    DATASTORE_NAME = {
        'name_or_flags': ['--datastore-name'],
        'options': {'action': 'store', 'help': 'Datastore name'}
    }
    CLUSTER_NAME = {
        'name_or_flags': ['--cluster-name'],
        'options': {'action': 'store', 'help': 'Cluster name'}
    }
    FOLDER_NAME = {
        'name_or_flags': ['--folder-name'],
        'options': {'action': 'store', 'help': 'Folder name'}
    }
    TEMPLATE = {
        'name_or_flags': ['--template'],
        'options': {'action': 'store', 'help': 'Name of the template/VM'}
    }
    VMFOLDER = {
        'name_or_flags': ['--vm-folder'],
        'options': {'action': 'store', 'help': 'Name of the VMFolder'}
    }
    DATASTORECLUSTER_NAME = {
        'name_or_flags': ['--datastorecluster-name'],
        'options': {'action': 'store', 'help': 'Datastorecluster (DRS Storagepod)'}
    }
    RESOURCE_POOL = {
        'name_or_flags': ['--resource-pool'],
        'options': {'action': 'store', 'help': 'Resource pool name'}
    }
    POWER_ON = {
        'name_or_flags': ['--power-on'],
        'options': {'action': 'store_true', 'help': 'power on the VM'}
    }
    LANGUAGE = {
        'name_or_flags': ['--language'],
        'options': {'action': 'store', 'default': 'English', 'help': 'Language your vcenter used.'}
    }
    VIHOST = {
        'name_or_flags': ['--vihost'],
        'options': {'action': 'store',
                    'help': 'Name/ip address of ESXi host as seen in vCenter Server'}
    }
    DVS_PORT_GROUP_NAME = {
        'name_or_flags': ['--dvs-pg-name'],
        'options': {'action': 'store', 'help': '"Name of the distributed port group'}
    }
    DVS_NAME = {
        'name_or_flags': ['--dvs-name'],
        'options': {'action': 'store', 'help': 'Name of the distributed virtual switch'}
    }
    OPAQUE_NETWORK_NAME = {
        'name_or_flags': ['--opaque-network-name'],
        'options': {'action': 'store', 'help': 'Name of an opaque network'}
    }
    FIRST_CLASS_DISK_NAME = {
        'name_or_flags': ['--fcd-name'],
        'options': {'action': 'store', 'help': 'First Class Disk name'}
    }
    DISK_TYPE = {
        'name_or_flags': ['--disk-type'],
        'options': {'action': 'store',
                    'default': 'thin', 'choices': ['thick', 'thin'], 'help': 'thick or thin'}
    }
    DISK_SIZE = {
        'name_or_flags': ['--disk-size'],
        'options': {'action': 'store', 'help': 'disk size, in GB, to add to the VM'}
    }
    PORT_GROUP = {
        'name_or_flags': ['-g', '--port-group'],
        'options': {'action': 'store', 'help': 'Name of port group'}
    }
    NETWORK_NAME = {
        'name_or_flags': ['--network-name'],
        'options': {'action': 'store', 'help': 'Name of network'}
    }
    VSWITCH_NAME = {
        'name_or_flags': ['-w', '--vswitch-name'],
        'options': {'action': 'store', 'help': 'vSwitch name'}
    }
    LOCAL_FILE_PATH = {
        'name_or_flags': ['--local-file-path'],
        'options': {'action': 'store', 'help': 'Local disk path to file'}
    }
    REMOTE_FILE_PATH = {
        'name_or_flags': ['--remote-file-path'],
        'options': {'action': 'store', 'help': 'Path on datastore or vm or other entity to file'}
    }
    VLAN_ID = {
        'name_or_flags': ['--vlan-id'],
        'options': {'action': 'store', 'help': 'Vlan ID'}
    }
    DEVICE_NAME = {
        'name_or_flags': ['--device-name'],
        'options': {'action': 'store', 'help': 'The device name. Might look like '
                                               '"/vmfs/devices/disks/naa.*". '
                                               'See vim.vm.device.VirtualDisk.'
                                               'RawDiskMappingVer1BackingInfo documentation.'}}
    DISK_MODE = {
        'name_or_flags': ['--disk-mode'],
        'options': {'action': 'store',
                    'default': 'independent_persistent',
                    'choices': [
                        'append',
                        'independent_nonpersistent',
                        'independent_persistent',
                        'nonpersistent',
                        'persistent',
                        'undoable'],
                    'help': 'See vim.vm.device.VirtualDiskOption.DiskMode documentation.'}}

    COMPATIBILITY_MODE = {
        'name_or_flags': ['--disk-compatibility-mode'],
        'options': {'action': 'store',
                    'default': 'virtualMode',
                    'choices': ['physicalMode', 'virtualMode'],
                    'help': 'See vim.vm.device.VirtualDiskOption.CompatibilityMode documentation.'}}

    ISO = {
        'name_or_flags': ['--iso'],
        'options': {'action': 'store',
                    'help': 'ISO to use in test. Use datastore path format. '
                            'E.g. [datastore1] path/to/file.iso'}
    }
    NIC_NAME = {
        'name_or_flags': ['--nic-name'],
        'options': {'action': 'store', 'help': 'NIC number.'}
    }
    NIC_UNIT_NUMBER = {
        'name_or_flags': ['--nic-unitnumber'],
        'options': {'action': 'store', 'type': int, 'help': 'NIC number.'}
    }
    NIC_STATE = {
        'name_or_flags': ['--nic-state'],
        'options': {'action': 'store', 'choices': ['delete', 'disconnect', 'connect'],
                    'help': 'NIC number.'}
    }
    VMDK_PATH = {
        'name_or_flags': ['--vmdk-path'],
        'options': {'action': 'store', 'help': 'Path of the VMDK file.'}
    }
    OVA_PATH = {
        'name_or_flags': ['--ova-path'],
        'options': {'action': 'store', 'help': 'Path to the OVA file.'}
    }
    OVF_PATH = {
        'name_or_flags': ['--ovf-path'],
        'options': {'action': 'store', 'help': 'Path to the OVF file.'}
    }
    DATE = {
        'name_or_flags': ['--date'],
        'options': {'action': 'store', 'help': 'Date and time with the format d/m/Y H:M'}
    }
    MINUTES = {
        'name_or_flags': ['--minutes'],
        'options': {'action': 'store', 'help': 'time in minutes'}
    }
    MESSAGE = {
        'name_or_flags': ['-m', '--message'],
        'options': {'action': 'store', 'help': 'Message'}
    }

    SNAPSHOT_OPERATION = {
        'name_or_flags': ['-op', '--snapshot-operation'],
        'options': {'action': 'store',
                    'choices':
                        ['create', 'remove', 'revert', 'list_all', 'list_current', 'remove_all'],
                    'help': 'Snapshot operation'}
    }
    SNAPSHOT_NAME = {
        'name_or_flags': ['--snapshot-name'],
        'options': {'action': 'store', 'help': 'Snapshot name'}
    }
    STORAGE_POLICY_NAME = {
        'name_or_flags': ['--storage-policy-name'],
        'options': {'action': 'store', 'metavar': 'string', 'help': 'Storage policy name'}
    }
    ASSUME_INPUT = {
        'name_or_flags': ['--assume-input'],
        'options': {'action': 'store', 'help': 'Assume user input'}
    }
    SSL_KEY = {
        'name_or_flags': ['--ssl-key'],
        'options': {'action': 'store', 'help': 'absolute location of the private key file'}
    }
    SSL_CERT = {
        'name_or_flags': ['--ssl-cert'],
        'options': {'action': 'store', 'help': 'absolute location of the certificate file'}
    }


def prompt_y_n_question(question, default="no"):
    """ based on:
        http://code.activestate.com/recipes/577058/
    :param question: Question to ask
    :param default: No
    :return: True/False
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("Invalid default answer: '{}'".format(default))

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please, respond with 'yes' or 'no' or 'y' or 'n'.")

```

```python
"""
This module implements simple helper functions for managing service instance objects
"""
__author__ = "VMware, Inc."

import atexit
from pyVim.connect import SmartConnect, Disconnect


def connect(args):
    """
    Determine the most preferred API version supported by the specified server,
    then connect to the specified server using that API version, login and return
    the service instance object.
    """

    service_instance = None

    # form a connection...
    try:
        if args.disable_ssl_verification:
            service_instance = SmartConnect(host=args.host,
                                            user=args.user,
                                            pwd=args.password,
                                            port=args.port,
                                            disableSslCertValidation=True)
        else:
            service_instance = SmartConnect(host=args.host,
                                            user=args.user,
                                            pwd=args.password,
                                            port=args.port)

        # doing this means you don't need to remember to disconnect your script/objects
        atexit.register(Disconnect, service_instance)
    except IOError as io_error:
        print(io_error)

    if not service_instance:
        raise SystemExit("Unable to connect to host with supplied credentials.")

    return service_instance

```

```python
"""
Property Collector helper module.
"""

import pyVmomi


# Shamelessly borrowed from:
# https://github.com/dnaeon/py-vconnector/blob/master/src/vconnector/core.py
def collect_properties(si, view_ref, obj_type, path_set=None,
                       include_mors=False):
    """
    Collect properties for managed objects from a view ref

    Check the vSphere API documentation for example on retrieving
    object properties:

        - http://goo.gl/erbFDz

    Args:
        si          (ServiceInstance): ServiceInstance connection
        view_ref (pyVmomi.vim.view.*): Starting point of inventory navigation
        obj_type      (pyVmomi.vim.*): Type of managed object
        path_set               (list): List of properties to retrieve
        include_mors           (bool): If True include the managed objects
                                       refs in the result

    Returns:
        A list of properties for the managed objects

    """
    collector = si.content.propertyCollector

    # Create object specification to define the starting point of
    # inventory navigation
    obj_spec = pyVmomi.vmodl.query.PropertyCollector.ObjectSpec()
    obj_spec.obj = view_ref
    obj_spec.skip = True

    # Create a traversal specification to identify the path for collection
    traversal_spec = pyVmomi.vmodl.query.PropertyCollector.TraversalSpec()
    traversal_spec.name = 'traverseEntities'
    traversal_spec.path = 'view'
    traversal_spec.skip = False
    traversal_spec.type = view_ref.__class__
    obj_spec.selectSet = [traversal_spec]

    # Identify the properties to the retrieved
    property_spec = pyVmomi.vmodl.query.PropertyCollector.PropertySpec()
    property_spec.type = obj_type

    if not path_set:
        property_spec.all = True

    property_spec.pathSet = path_set

    # Add the object and property specification to the
    # property filter specification
    filter_spec = pyVmomi.vmodl.query.PropertyCollector.FilterSpec()
    filter_spec.objectSet = [obj_spec]
    filter_spec.propSet = [property_spec]

    # Retrieve properties
    props = collector.RetrieveContents([filter_spec])

    data = []
    for obj in props:
        properties = {}
        for prop in obj.propSet:
            properties[prop.name] = prop.val

        if include_mors:
            properties['obj'] = obj.obj

        data.append(properties)
    return data


def get_container_view(si, obj_type, container=None):
    """
    Get a vSphere Container View reference to all objects of type 'obj_type'

    It is up to the caller to take care of destroying the View when no longer
    needed.

    Args:
        obj_type (list): A list of managed object types

    Returns:
        A container view ref to the discovered managed objects
    """
    if not container:
        container = si.content.rootFolder

    view_ref = si.content.viewManager.CreateContainerView(
        container=container,
        type=obj_type,
        recursive=True
    )
    return view_ref


def search_for_obj(content, vim_type, name, folder=None, recurse=True):
    """
    Search the managed object for the name and type specified

    Sample Usage:

    get_obj(content, [vim.Datastore], "Datastore Name")
    """
    if folder is None:
        folder = content.rootFolder

    obj = None
    container = content.viewManager.CreateContainerView(folder, vim_type, recurse)

    for managed_object_ref in container.view:
        if managed_object_ref.name == name:
            obj = managed_object_ref
            break
    container.Destroy()
    return obj


def get_all_obj(content, vim_type, folder=None, recurse=True):
    """
    Search the managed object for the name and type specified

    Sample Usage:

    get_obj(content, [vim.Datastore], "Datastore Name")
    """
    if not folder:
        folder = content.rootFolder

    obj = {}
    container = content.viewManager.CreateContainerView(folder, vim_type, recurse)

    for managed_object_ref in container.view:
        obj[managed_object_ref] = managed_object_ref.name

    container.Destroy()
    return obj


def get_obj(content, vim_type, name, folder=None, recurse=True):
    """
    Retrieves the managed object for the name and type specified
    Throws an exception if of not found.

    Sample Usage:

    get_obj(content, [vim.Datastore], "Datastore Name")
    """
    obj = search_for_obj(content, vim_type, name, folder, recurse)
    if not obj:
        raise RuntimeError("Managed Object " + name + " not found.")
    return obj

```

