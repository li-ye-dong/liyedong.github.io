[https://techdocs.broadcom.com/cn/zh-cn/vmware-cis/vsphere/vsphere/8-0/vsphere-virtual-machine-administration-guide-8-0/managing-virtual-machinesvsphere-vm-admin/customizing-guest-operating-systemsvsphere-vm-admin/create-and-manage-customization-specificationsvsphere-vm-admin.html](https://techdocs.broadcom.com/cn/zh-cn/vmware-cis/vsphere/vsphere/8-0/vsphere-virtual-machine-administration-guide-8-0/managing-virtual-machinesvsphere-vm-admin/customizing-guest-operating-systemsvsphere-vm-admin/create-and-manage-customization-specificationsvsphere-vm-admin.html)

<font style="color:rgb(0, 0, 0);">运行自定义脚本：</font>

+ <font style="color:rgb(0, 0, 0);">确认已安装 VMware Tools 版本 10.1.0 或更高版本。如果 VMware Tools 版本低于 10.1.0，则您尝试运行自定义脚本时，自定义将失败。</font>
+ <font style="color:rgb(0, 0, 0);">在 VMware Tools 配置中，出于安全原因，enable-custom-scripts 选项默认处于取消激活状态。尝试在 enable-custom-scripts 选项处于取消激活状态的情况下运行自定义脚本时，自定义将失败并显示自定义错误。例如，要启用 enable-custom-scripts 选项，必须使用 config 命令以 root 用户身份运行 vmware-toolbox-cmd：</font>

```plain
vmware-toolbox-cmd config set deployPkg enable-custom-scripts true
cat /etc/vmware-tools/tools.conf
[deployPkg]
enable-custom-scripts = true
```

<font style="color:rgb(0, 0, 0);">要验证是否正确设置了该选项，可以运行以下命令：</font>

```plain
vmware-toolbox-cmd config get deployPkg enable-custom-scripts
[deployPkg] enable-custom-scripts = true
```

```powershell
cd 'c:\Profile Files\VMware\VMware Tools\'
.\VMwareToolboxCmd.exe config get deployPkg enable-custom-scripts
.\VMwareToolboxCmd.exe config set deployPkg enable-custom-scripts true
.\VMwareToolboxCmd.exe config get deployPkg enable-custom-scripts
```





安装perl

```python
mkdir -p /mnt/cdrom
mount /dev/sr0 /mnt/cdrom
cat > /etc/yum.repos.d/rhel8-local.repo <<EOF
[BaseOS]
name=RHEL 8.10 BaseOS
baseurl=file:///mnt/cdrom/BaseOS
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release

[AppStream]
name=RHEL 8.10 AppStream
baseurl=file:///mnt/cdrom/AppStream
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release
EOF


dnf install -y perl
```

可选，避免后续失效

```python
tee > /etc/systemd/system/vmware-custom-scripts.service << 'EOF'
[Unit]
Description=Enable VMware Custom Scripts
After=vmware-tools.service

[Service]
Type=oneshot
ExecStart=/usr/bin/vmware-toolbox-cmd config set deployPkg enable-custom-scripts true

[Install]
WantedBy=multi-user.target
EOF
sudo systemctl daemon-reload
sudo systemctl enable vmware-custom-scripts.service
```

python实现

[https://gitee.com/sdfsdfs445/vsphere-scripts.git](https://gitee.com/sdfsdfs445/vsphere-scripts.git)

范例

| **<font style="color:#000000;">vm_note</font>** | **<font style="color:#000000;">vm_type</font>** | **<font style="color:#000000;">vm_name</font>** | **<font style="color:#000000;">template</font>** | **<font style="color:#000000;">disk_size</font>** | **<font style="color:#000000;">vm_ip</font>** | **<font style="color:#000000;">vm_gateway</font>** | **<font style="color:#000000;">vm_netmask</font>** | **<font style="color:#000000;">vm_dns</font>** | **<font style="color:#000000;">vm_vlan_name</font>** | **<font style="color:#000000;">vm_cpu</font>** | **<font style="color:#000000;">vm_memory</font>** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">windows</font> | <font style="color:#000000;">AD-M-kehua-xm1</font> | <font style="color:#000000;">windows2019-template</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.108.7</font> | <font style="color:#000000;">192.168.108.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan108</font> | <font style="color:#000000;">4</font> | <font style="color:#000000;">16</font> |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">linux</font> | <font style="color:#000000;">test-archery</font> | <font style="color:#000000;">rhelmini8.10-template-100G</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.107.65</font> | <font style="color:#000000;">192.168.107.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan107</font> | <font style="color:#000000;">8</font> | <font style="color:#000000;">16</font> |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">windows</font> | <font style="color:#000000;">AD-M-kehua-xm1</font> | <font style="color:#000000;">windows2016-template</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.108.7</font> | <font style="color:#000000;">192.168.108.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan108</font> | <font style="color:#000000;">4</font> | <font style="color:#000000;">16</font> |
| <font style="color:#000000;">xx</font> | <font style="color:#000000;">linux</font> | <font style="color:#000000;">test-archery</font> | <font style="color:#000000;">rhelmini7.9-template-100G</font> | <font style="color:#000000;">200</font> | <font style="color:#000000;">192.168.107.65</font> | <font style="color:#000000;">192.168.107.1</font> | <font style="color:#000000;">24</font> | <font style="color:#000000;">192.168.105.12,192.168.105.11</font> | <font style="color:#000000;">vlan107</font> | <font style="color:#000000;">8</font> | <font style="color:#000000;">16</font> |


通过xlsx调用exe文件进行批量创建

```python
import subprocess
import pandas as pd
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
# vCenter 通用信息
VCENTER_IP = "192.168.56.xxx"
VCENTER_USER = "xxx@xxx.org"
VCENTER_PASS = "xxxx"
NO_SSL = "-nossl"
THREADS = 3  # 线程数
# 可执行文件路径
EXE_WINDOWS = "create_cus_rule_by_windows.exe"
EXE_LINUX = "create_cus_rule_by_bash.exe"
import re

def escape_note(text):
    # Windows CMD 中这些字符有特殊含义：< > | & ^ % ! "
    return re.sub(r'([<>&|^%!"])', r'^\1', text)  # ^进行转义



def run_create_vm(row):
    vm_type = row['vm_type']
    exe = EXE_WINDOWS if vm_type.lower() == "windows" else EXE_LINUX
    note = str(row['vm_note']).replace('"', "'")  # 避免双引号冲突
    cmd = [
        f".\\{exe}",
        "-s", VCENTER_IP,
        "-u", VCENTER_USER,
        "-p", VCENTER_PASS,
        NO_SSL,
        "--template", str(row["template"]),
        "--disk-size", str(row["disk_size"]),
        "-v", str(row["vm_name"]),
        "--vm_ip", str(row["vm_ip"]),
        "--vm_gateway", str(row["vm_gateway"]),
        "--vm_netmask", str(row["vm_netmask"]),
        "--vm_dns", str(row["vm_dns"]),
        "--vm_vlan_name", str(row["vm_vlan_name"]),
        "--vm_cpu", str(row["vm_cpu"]),
        "--vm_memory", str(row["vm_memory"]),
        "--vm_note", f'"{note}"',   # 用双引号包裹完整备注字符串
    ]
    try:
        print(f"🟡 正在创建虚拟机：{row['vm_name']}")
        result = subprocess.run(cmd, capture_output=True, text=True, shell=True)
        with open(f"log_{row['vm_name']}.log", "w", encoding="utf-8") as f:
            f.write(result.stdout + "\n" + result.stderr)
        if result.returncode == 0:
            print(f"🟢 虚拟机 {row['vm_name']} 创建成功")
            print(result.stdout)
        else:
            print(f"🔴 虚拟机 {row['vm_name']} 创建失败：\n{result.stderr}")
    except Exception as e:
        print(f"🔴 虚拟机 {row['vm_name']} 创建异常：{str(e)}")

def main():
    # 从 Excel 读取
    df = pd.read_excel("vm_list.xlsx",sheet_name="VMList")

    # 使用线程创建虚拟机
    # 使用线程池，每次并发 3 台虚拟机
    with ThreadPoolExecutor(max_workers=THREADS) as executor:
        futures = [executor.submit(run_create_vm, row) for index, row in df.iterrows()]
        for future in as_completed(futures):
            future.result()  # 捕获异常

    print("✅ 所有虚拟机创建任务已完成。")

if __name__ == "__main__":
    main()

```

已经实现rhel 7/8 debian12的ip自动配置，lvm自动挂载

```python
import threading
import time

from pyVmomi import vim
from tools import cli, service_instance, pchelper
from pyVim.task import WaitForTask


def wait_for_task(task):
    """ 等待 vCenter 任务完成 """
    task_done = False
    while not task_done:
        if task.info.state == 'success':
            return task.info.result
        if task.info.state == 'error':
            print("出现错误")
            print(task.info.error)
            task_done = True



def set_note(vm, annotation):
    # 创建一个虚拟机配置规范，并设置备注
    spec = vim.vm.ConfigSpec()
    spec.annotation = annotation

    # 提交配置任务
    task = vm.ReconfigVM_Task(spec)
    while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
        continue

    print(f"已更新虚拟机{vm.name}的备注为：{annotation}")
def check_vm_tool(vm, timeout=30):
    temp = 0
    while True:
        time.sleep(1)
        temp = temp + 1
        try:
            print(f"tool状态检查中第{temp}次")
            if vm.guest.toolsStatus == "toolsOk":
                break
        except Exception as e:
            print(f"错误{e}")
            break
        if temp == timeout:
            print(f"超时")
            break


def run_script_in_vm(si, vm, script_text, username, password, os_type='linux'):
    """
    在虚拟机中通过 VMware Tools 执行脚本，支持 Linux 和 Windows
    :param si: 服务实例
    :param vm: 虚拟机对象
    :param script_text: 需要执行的脚本内容
    :param username: 虚拟机的用户名
    :param password: 虚拟机的密码
    :param os_type: 虚拟机操作系统类型，'linux' 或 'windows'
    """
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)

    pm = si.content.guestOperationsManager.processManager

    if os_type.lower() == 'linux':
        # Linux 用 /bin/bash 执行
        program_path = '/bin/bash'
        arguments = fr'-c "{script_text}"'
        print(f'传入{arguments}')
    elif os_type.lower() == 'windows':
        # Windows 用 cmd.exe /c 执行，脚本写成一条命令
        program_path = r'C:\Windows\System32\cmd.exe'
        # Windows cmd 执行脚本时需要转义双引号，且 /c 后接命令
        # 这里用一条命令执行，如果是多行复杂脚本建议先上传脚本文件再执行
        # 直接传脚本内容时建议写成单条命令或用 & 连接多个命令
        escaped_script = script_text.replace('"', '\\"')
        arguments = f'/c "{escaped_script}"'
    else:
        raise ValueError(f"不支持的操作系统类型: {os_type}")

    ps = vim.vm.guest.ProcessManager.ProgramSpec(programPath=program_path, arguments=arguments)
    pid = pm.StartProgramInGuest(vm, creds, ps)
    print(f"已在虚拟机 {vm.name} 中启动进程，PID: {pid}")
    return pid


def run_program_in_guest_sync(si, vm, username, password, program_path, arguments, timeout=300):
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    pm = si.content.guestOperationsManager.processManager

    ps = vim.vm.guest.ProcessManager.ProgramSpec(programPath=program_path, arguments=arguments)
    pid = pm.StartProgramInGuest(vm, creds, ps)
    print(f"启动进程 PID: {pid}")

    start_time = time.time()
    while True:
        processes = pm.ListProcessesInGuest(vm, creds, [pid])
        if not processes:
            print("进程不存在，可能已经结束。")
            break
        proc = processes[0]
        if proc.exitCode is not None:
            print(f"进程已结束，退出码: {proc.exitCode}")
            return proc.exitCode
        if time.time() - start_time > timeout:
            print("等待进程超时，结束等待")
            return None
        time.sleep(2)


def upload_file(si, vm, local_content, remote_path, username, password):
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    file_manager = si.content.guestOperationsManager.fileManager

    # 先把内容转成bytes
    data = local_content.encode('utf-8')

    # 计算文件大小
    file_size = len(data)

    # 上传文件的URL（需要用fileManager获取上传URL）
    url = file_manager.InitiateFileTransferToGuest(vm, creds, remote_path,
                                                   vim.vm.guest.FileManager.FileAttributes(),
                                                   file_size, True)


def upload_script_and_run_sync(si, vm, script_content, remote_path,username, password, timeout=300):
    import base64
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    gm = si.content.guestOperationsManager.fileManager
    pm = si.content.guestOperationsManager.processManager

    # base64 编码脚本内容
    encoded_script = base64.b64encode(script_content.encode('utf-8')).decode('utf-8')

    # 通过 echo base64 解码写文件的命令
    script_cmd = f"echo {encoded_script} | base64 -d > {remote_path} && chmod +x {remote_path} && {remote_path}"
    # 启动上传进程
    program_spec_upload = vim.vm.guest.ProcessManager.ProgramSpec(
        programPath="/bin/bash",
        arguments=f"-c \"{script_cmd}\""
    )
    pid_upload = pm.StartProgramInGuest(vm, creds, program_spec_upload)
    print(f"上传脚本并且执行进程PID: {pid_upload}")

    # 轮询等待进程结束
    start_time = time.time()
    while True:
        processes = pm.ListProcessesInGuest(vm, creds, [pid_upload])
        if not processes:
            print("进程不存在，可能已结束。")
            return None
        proc = processes[0]
        if proc.exitCode is not None:
            print(f"上传进程已结束，退出码: {proc.exitCode}")
            return proc.exitCode
        if time.time() - start_time > timeout:
            print("上传进程等待超时")
            return None
        time.sleep(2)


def update_nic_network(si, vm_name, new_network_name):
    """
    修改虚拟机第一块网卡连接的网络标签（端口组）
    :param si: vSphere service instance
    :param vm: 虚拟机对象
    :param new_network_name: 新的网络标签（端口组名称）
    """
    content = si.RetrieveContent()
    new_network = pchelper.get_obj(content, [vim.Network], new_network_name)
    if not new_network:
        raise RuntimeError(f"找不到网络标签：{new_network_name}")
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        raise RuntimeError(f"未找到虚拟机{vm_name}")
    # 查找现有的网卡设备（以第一块为例）
    nic_device = None
    for device in vm.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if not nic_device:
        raise RuntimeError("未找到虚拟机网卡")

    # 修改 backing（标准端口组或分布式交换机）
    if isinstance(new_network, vim.dvs.DistributedVirtualPortgroup):
        port = vim.dvs.PortConnection()
        port.portgroupKey = new_network.key
        port.switchUuid = new_network.config.distributedVirtualSwitch.uuid

        nic_device.backing = vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo()
        nic_device.backing.port = port
    else:
        nic_device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
        nic_device.backing.deviceName = new_network_name
        nic_device.backing.network = new_network

    # ✅ 开启网卡连接并勾选“开机时连接”
    nic_device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
    nic_device.connectable.startConnected = True  # 开机自连接
    nic_device.connectable.allowGuestControl = True
    nic_device.connectable.connected = True

    # 构造配置 spec
    nic_spec = vim.vm.device.VirtualDeviceSpec()
    nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    nic_spec.device = nic_device

    spec = vim.vm.ConfigSpec()
    spec.deviceChange = [nic_spec]

    # 应用配置
    task = vm.ReconfigVM_Task(spec=spec)
    wait_for_task(task)
    print(f"已修改网卡连接到网络：{new_network_name}")


def clone_vm_with_customization(content, template_name, vm_name, datacenter_name, vm_folder, datastore_name,
                                cluster_name, resource_pool, power_on, datastorecluster_name, customization_spec,
                                cpu, memory):
    """
    从模板/虚拟机克隆虚拟机并应用自定义规范（CustomizationSpec）
    """
    template = pchelper.get_obj(content, [vim.VirtualMachine], template_name)
    if template is None:
        print(f"未找到虚拟机{template}")
        return
    # 获取数据中心、文件夹、数据存储、集群和资源池等信息
    datacenter = pchelper.get_obj(content, [vim.Datacenter], datacenter_name)
    if vm_folder:
        destfolder = pchelper.search_for_obj(content, [vim.Folder], vm_folder)
    else:
        destfolder = datacenter.vmFolder

    if datastore_name:
        datastore = pchelper.search_for_obj(content, [vim.Datastore], datastore_name)
    else:
        datastore = pchelper.get_obj(content, [vim.Datastore], template.datastore[0].info.name)

    # 获取集群和资源池
    cluster = pchelper.search_for_obj(content, [vim.ClusterComputeResource], cluster_name)
    if not cluster:
        clusters = pchelper.get_all_obj(content, [vim.ResourcePool])
        cluster = list(clusters)[0]

    if resource_pool:
        resource_pool = pchelper.search_for_obj(content, [vim.ResourcePool], resource_pool)
    else:
        resource_pool = cluster.resourcePool

    # 设置克隆规格
    relospec = vim.vm.RelocateSpec()
    relospec.datastore = datastore
    relospec.pool = resource_pool
    # 正确设置配置参数
    clonespec = vim.vm.CloneSpec()
    vmconf = vim.vm.ConfigSpec()
    vmconf.numCPUs = cpu
    vmconf.numCoresPerSocket = cpu  # 可选：每个 socket 的核数
    vmconf.memoryMB = memory * 1024  # 单位 MB，不需要乘 1024

    # 获取模板的第一个网卡，修改连接状态
    nic_device = None
    for device in template.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if nic_device:
        nic_spec = vim.vm.device.VirtualDeviceSpec()
        nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        nic_spec.device = nic_device

        # 强制设置连接属性
        nic_spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
        nic_spec.device.connectable.startConnected = True
        nic_spec.device.connectable.allowGuestControl = True
        nic_spec.device.connectable.connected = True

        vmconf.deviceChange = [nic_spec]  # 加入设备变更
    clonespec.config = vmconf

    clonespec.location = relospec
    clonespec.powerOn = power_on
    clonespec.customization = customization_spec  # 在克隆规范中应用自定义规范

    print(f"正在从模板 {template_name} 克隆虚拟机 {vm_name}...")
    task = template.Clone(folder=destfolder, name=vm_name, spec=clonespec)
    try:
        wait_for_task(task)
        print(f"虚拟机 {vm_name} 克隆完成并应用了自定义规范")
        return pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    except Exception as e:
        raise RuntimeError(f"克隆失败: {str(e)}")


def power_vm(vm_name, status):
    """启动虚拟机"""
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        print("未找到虚拟机")
        return
    if status == "on":
        print("正在启动虚拟机 %s..." % vm.name)
        task = vm.PowerOn()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            print("启动中...")
            time.sleep(1)
    elif status == "off":
        print("正在关闭虚拟机 %s..." % vm.name)
        task = vm.PowerOff()
        while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
            print("关闭中...")
            time.sleep(1)

    if task.info.state == vim.TaskInfo.State.success:
        print("虚拟机 %s 已经启动。" % vm.name)
    else:
        print("启动虚拟机失败，错误信息：%s" % task.info.error.localizedMessage)


def add_disk(vm_name, disk_size, disk_type):
    """
    向虚拟机添加硬盘
    """
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        print("未找到虚拟机")
        return
    spec = vim.vm.ConfigSpec()
    # 获取虚拟机上的所有磁盘，设置下一个可用的 unit_number
    unit_number = 0
    controller = None
    for device in vm.config.hardware.device:
        if hasattr(device.backing, 'fileName'):
            unit_number = int(device.unitNumber) + 1
            # unit_number 7 保留给 SCSI 控制器
            if unit_number == 7:
                unit_number += 1
            if unit_number >= 16:
                print("我们不支持这么多磁盘")
                return -1
        if isinstance(device, vim.vm.device.VirtualSCSIController):
            controller = device
    if controller is None:
        print("未找到磁盘 SCSI 控制器！")
        return -1
    # 在此处添加磁盘
    dev_changes = []
    new_disk_kb = int(disk_size) * 1024 * 1024
    disk_spec = vim.vm.device.VirtualDeviceSpec()
    disk_spec.fileOperation = "create"
    disk_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
    disk_spec.device = vim.vm.device.VirtualDisk()
    disk_spec.device.backing = \
        vim.vm.device.VirtualDisk.FlatVer2BackingInfo()
    if disk_type == 'thin':
        disk_spec.device.backing.thinProvisioned = True
    disk_spec.device.backing.diskMode = 'persistent'
    disk_spec.device.unitNumber = unit_number
    disk_spec.device.capacityInKB = new_disk_kb
    disk_spec.device.controllerKey = controller.key
    dev_changes.append(disk_spec)
    spec.deviceChange = dev_changes
    WaitForTask(vm.ReconfigVM_Task(spec=spec))
    print("%sGB 硬盘已添加到 %s" % (disk_size, vm.config.name))
    return 0


parser = cli.Parser()
parser.add_required_arguments(
    cli.Argument.VM_NAME,
    cli.Argument.DISK_SIZE,
    cli.Argument.TEMPLATE,
)
parser.add_custom_argument('--vm_ip', required=True, action='store', help='虚拟机ip 192.168.10.111')
parser.add_custom_argument('--vm_gateway', required=True, action='store', help='虚拟机网关 192.168.10.1')
parser.add_custom_argument('--vm_netmask', required=True, action='store', help='虚拟机掩码 24')
parser.add_custom_argument('--vm_dns', required=True, action='store', help='虚拟机dns 192.168.105.12,192.168.105.11')
parser.add_custom_argument('--vm_vlan_name', required=True, action='store', help='虚拟机的vlan vlan107')
parser.add_custom_argument('--vm_cpu', type=int, required=True, action='store', help='虚拟机的cpu')
parser.add_custom_argument('--vm_memory', type=int, required=True, action='store', help='虚拟机的memory Gb')
parser.add_custom_argument('--vm_note', required=True, action='store', help='虚拟机的备注')
args = parser.get_args()


# from types import SimpleNamespace
#
# args = SimpleNamespace(
#     host="192.168.107.101",
#     user="administrator@vsphere.local",
#     password="P@ssw0rd",
#     vm_name="test-liyedong",
#     port=443,
#     disable_ssl_verification=True,  # 新增此字段，防止报错
#     # template="debian12-template",
#     template="rocky9-template",
#     disk_size=10,
#     vm_ip="192.168.107.110",
#     vm_gateway="192.168.107.2",
#     vm_netmask="24",
#     vm_dns="114.114.114.114,8.8.8.8",
#     vm_vlan_name="vlan107",
#     vm_cpu=2,
#     vm_memory=2,
# )

si = service_instance.connect(args)

content = si.RetrieveContent()

# === 获取目标组件 ===


# === 自定义 IP/网关/DNS 等 ===
# adapter = vim.vm.customization.AdapterMapping()
# adapter.adapter = vim.vm.customization.IPSettings()
# adapter.adapter.ip = vim.vm.customization.FixedIp()
# adapter.adapter.ip.ipAddress = args.vm_ip
# adapter.adapter.subnetMask = args.vm_netmask
# adapter.adapter.gateway = [args.vm_gateway]
# adapter.adapter.dnsDomain = "localdomain"
#
# dns_list = args.vm_dns.split(",")
#
# identity = vim.vm.customization.LinuxPrep()
# identity.hostName = vim.vm.customization.FixedName(name=args.vm_name)
# identity.domain = "localdomain"
# identity.timeZone = "Asia/Shanghai"
#
# global_ip = vim.vm.customization.GlobalIPSettings()
# global_ip.dnsServerList = dns_list
#
# custom_spec = vim.vm.customization.Specification()
# custom_spec.nicSettingMap = [adapter]
# custom_spec.identity = identity
# custom_spec.globalIPSettings = global_ip

# === 克隆配置 ===

# 克隆虚拟机
try:
    vm = clone_vm_with_customization(
        content,
        args.template,
        args.vm_name,
        'DC-A4-XM-ZD-DataCenter',
        None,
        'A4-XM-ZD-56.30-SATA-DS01',
        'DC-A4-XM-ZD-Cluster01',
        None,
        True,
        None,
        # custom_spec,
        None,
        args.vm_cpu,
        args.vm_memory
    )
    # vm = clone_vm_with_customization(
    #     content,
    #     args.template,
    #     args.vm_name,
    #     'Datacenter',
    #     None,
    #     'data',
    #     None,
    #     None,
    #     True,
    #     None,
    #     # custom_spec,
    #     None,
    #     args.vm_cpu,
    #     args.vm_memory
    # )
    print(f"虚拟机 {args.vm_name} 创建成功")
except Exception as e:
    print(f"错误: {str(e)}")
# === 挂载新硬盘 ===
add_disk(args.vm_name, args.disk_size, 'thin')

# 指定vlan
update_nic_network(si, args.vm_name, args.vm_vlan_name)
vm_obj = pchelper.get_obj(content, [vim.VirtualMachine], args.vm_name)
if vm_obj is None:
    print("未找到虚拟机")
set_note(vm_obj, args.vm_note)
check_vm_tool(vm_obj)
time.sleep(5)
bash_script = fr'''
#!/bin/bash
exec > /root/customize_vm.log 2>&1
set -ex

hostnamectl set-hostname {args.vm_name}

OS_FAMILY=$(grep ^ID= /etc/os-release | cut -d= -f2 | tr -d '"')
INTERFACE=$(ip route | grep default | awk '{{print $5}}')
echo "$OS_FAMILY" >> /root/customize_vm.log
echo "$INTERFACE" >> /root/customize_vm.log
if [ "$OS_FAMILY" = "debian" ]; then
  # Debian - 修改 /etc/network/interfaces
cat > /etc/network/interfaces <<ONEEOF
auto lo
iface lo inet loopback

auto $INTERFACE
iface $INTERFACE inet static
  address {args.vm_ip}
  netmask {args.vm_netmask}
  gateway {args.vm_gateway}
  dns-nameservers {args.vm_dns}
ONEEOF
  ifdown $INTERFACE || true
  ifup $INTERFACE

elif [ "$OS_FAMILY" = "ubuntu" ]; then
  # Ubuntu - 使用 netplan（17.10+）
cat > /etc/netplan/01-netcfg.yaml <<TWOEOF
network:
  version: 2
  renderer: networkd
  ethernets:
    $INTERFACE:
      dhcp4: no
      addresses:
        - {args.vm_ip}/{args.vm_netmask}
      gateway4: {args.vm_gateway}
      nameservers:
        addresses: [{args.vm_dns}]
TWOEOF
  netplan apply

# === RHEL / Rocky / AlmaLinux 系列 ===
else

  nmcli con mod "$INTERFACE" ipv4.addresses {args.vm_ip}/{args.vm_netmask} 
  nmcli con mod "$INTERFACE" ipv4.gateway {args.vm_gateway} 
  nmcli con mod "$INTERFACE" ipv4.dns "{args.vm_dns}" 
  nmcli con mod "$INTERFACE" ipv4.method manual 
  nmcli con mod "$INTERFACE" connection.autoconnect yes 
  nmcli con down "$INTERFACE" || true
  nmcli con up "$INTERFACE"
fi

# === 挂载数据盘部分 ===
if [ -b /dev/sdb ] && ! vgdisplay my_vg &>/dev/null; then
  echo "开始配置 LVM 数据盘：/dev/sdb -> /u01"
  # 创建物理卷（PV）
  pvcreate /dev/sdb
  # 创建卷组（VG）
  vgcreate my_vg /dev/sdb
  # 创建逻辑卷（LV）占用全部空间
  lvcreate -l 100%FREE -n my_lv my_vg
  # 格式化为 ext4 文件系统
  mkfs.ext4 /dev/my_vg/my_lv
  # 创建挂载点目录
  mkdir -p /u01
  # 添加挂载信息到 /etc/fstab（如果还没有）
  grep -q '/u01' /etc/fstab || echo '/dev/my_vg/my_lv /u01 ext4 defaults 0 0' >> /etc/fstab
  # 挂载所有文件系统
  mount -a
else
  echo "跳过 LVM 配置：/dev/sdb 不存在或卷组 my_vg 已存在"
fi
'''
upload_script_and_run_sync(si, vm_obj, bash_script,'/root/init.sh', "root", "P@ssw0rd")
#upload_script_and_run_sync(si, vm_obj, bash_script,'/root/init.sh', "root", "root")
# time.sleep(30)
# power_vm(args.vm_name, "off")
# time.sleep(3)
# power_vm(args.vm_name, "on")
# time.sleep(60)
# check_vm_tool(vm_obj)
# run_script_in_vm(si, vm_obj, r'/bin/bash /root/init.sh', "root", "root")


"""
pyinstaller -F --add-data "tools;tools" --hidden-import pyVmomi --hidden-import pyVim --hidden-import pyVim.connect --hidden-import openpyxl --hidden-import gooey create_cus_rule_by_bash.py
.\create_cus_rule.exe `
-s 192.168.xxx.8 `
-u xxx@xxxx.org `
-p xxxx `
-v test-liyedong `
-nossl `
--template rhelmini8.10-template-100G  `
--disk-size 50 `
--vm_ip 192.168.107.100 `
--vm_gateway 192.168.107.1 `
--vm_netmask 24 `
--vm_dns 192.168.105.12,192.168.105.11 `
--vm_vlan_name vlan107 `
--vm_cpu 10 `
--vm_memory 10 
--vm_disk_type ext4 #还未开发
"""

```

实现windows的自动克隆创建，并且实现sid更新，ip自动配置，磁盘自动分区，模板需要把驱动器盘符修改成D盘，测试通过2016、2019

```python
import time

from pyVmomi import vim
from tools import cli, service_instance, pchelper
from pyVim.task import WaitForTask


def wait_for_task(task):
    """ 等待 vCenter 任务完成 """
    task_done = False
    while not task_done:
        if task.info.state == 'success':
            return task.info.result
        if task.info.state == 'error':
            print("出现错误")
            print(task.info.error)
            task_done = True

def set_note(vm, annotation):
    # 创建一个虚拟机配置规范，并设置备注
    spec = vim.vm.ConfigSpec()
    spec.annotation = annotation

    # 提交配置任务
    task = vm.ReconfigVM_Task(spec)
    while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:
        continue

    print(f"已更新虚拟机{vm.name}的备注为：{annotation}")

def run_script_in_vm(si, vm, script_text, username, password, os_type='linux'):
    """
    在虚拟机中通过 VMware Tools 执行脚本，支持 Linux 和 Windows
    :param si: 服务实例
    :param vm: 虚拟机对象
    :param script_text: 需要执行的脚本内容
    :param username: 虚拟机的用户名
    :param password: 虚拟机的密码
    :param os_type: 虚拟机操作系统类型，'linux' 或 'windows'
    """
    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)

    pm = si.content.guestOperationsManager.processManager

    if os_type.lower() == 'linux':
        # Linux 用 /bin/bash 执行
        program_path = '/bin/bash'
        arguments = f'-c "{script_text}"'
    elif os_type.lower() == 'windows':
        # Windows 用 cmd.exe /c 执行，脚本写成一条命令
        program_path = r'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe'
        # Windows cmd 执行脚本时需要转义双引号，且 /c 后接命令
        # 这里用一条命令执行，如果是多行复杂脚本建议先上传脚本文件再执行
        # 直接传脚本内容时建议写成单条命令或用 & 连接多个命令
        # escaped_script = script_text.replace('"', '\\"')
        arguments = fr'powershell.exe -Command {script_text}'
        print(fr"执行{program_path} {arguments}")
    else:
        raise ValueError(f"不支持的操作系统类型: {os_type}")

    ps = vim.vm.guest.ProcessManager.ProgramSpec(programPath=program_path, arguments=arguments)

    pid = pm.StartProgramInGuest(vm, creds, ps)
    print(f"已在虚拟机 {vm.name} 中启动进程，PID: {pid}")
    return pid

def update_nic_network(si, vm_name, new_network_name):
    """
    修改虚拟机第一块网卡连接的网络标签（端口组）
    :param si: vSphere service instance
    :param vm: 虚拟机对象
    :param new_network_name: 新的网络标签（端口组名称）
    """
    content = si.RetrieveContent()
    new_network = pchelper.get_obj(content, [vim.Network], new_network_name)
    if not new_network:
        raise RuntimeError(f"找不到网络标签：{new_network_name}")
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        raise RuntimeError(f"未找到虚拟机{vm_name}")
    # 查找现有的网卡设备（以第一块为例）
    nic_device = None
    for device in vm.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if not nic_device:
        raise RuntimeError("未找到虚拟机网卡")

    # 修改 backing（标准端口组或分布式交换机）
    if isinstance(new_network, vim.dvs.DistributedVirtualPortgroup):
        port = vim.dvs.PortConnection()
        port.portgroupKey = new_network.key
        port.switchUuid = new_network.config.distributedVirtualSwitch.uuid

        nic_device.backing = vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo()
        nic_device.backing.port = port
    else:
        nic_device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
        nic_device.backing.deviceName = new_network_name
        nic_device.backing.network = new_network

    # ✅ 开启网卡连接并勾选“开机时连接”
    nic_device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
    nic_device.connectable.startConnected = True  # 开机自连接
    nic_device.connectable.allowGuestControl = True
    nic_device.connectable.connected = True

    # 构造配置 spec
    nic_spec = vim.vm.device.VirtualDeviceSpec()
    nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    nic_spec.device = nic_device

    spec = vim.vm.ConfigSpec()
    spec.deviceChange = [nic_spec]


    # 应用配置
    task = vm.ReconfigVM_Task(spec=spec)
    wait_for_task(task)
    print(f"已修改网卡连接到网络：{new_network_name}")


def clone_vm_with_customization(content, template_name, vm_name, datacenter_name, vm_folder, datastore_name,
                                cluster_name, resource_pool, power_on, datastorecluster_name, customization_spec,
                                cpu, memory):
    """
    从模板/虚拟机克隆虚拟机并应用自定义规范（CustomizationSpec）
    """
    template = pchelper.get_obj(content, [vim.VirtualMachine], template_name)
    if template is None:
        print(f"未找到虚拟机{template}")
        return
    # 获取数据中心、文件夹、数据存储、集群和资源池等信息
    datacenter = pchelper.get_obj(content, [vim.Datacenter], datacenter_name)
    if vm_folder:
        destfolder = pchelper.search_for_obj(content, [vim.Folder], vm_folder)
    else:
        destfolder = datacenter.vmFolder

    if datastore_name:
        datastore = pchelper.search_for_obj(content, [vim.Datastore], datastore_name)
    else:
        datastore = pchelper.get_obj(content, [vim.Datastore], template.datastore[0].info.name)

    # 获取集群和资源池
    cluster = pchelper.search_for_obj(content, [vim.ClusterComputeResource], cluster_name)
    if not cluster:
        clusters = pchelper.get_all_obj(content, [vim.ResourcePool])
        cluster = list(clusters)[0]

    if resource_pool:
        resource_pool = pchelper.search_for_obj(content, [vim.ResourcePool], resource_pool)
    else:
        resource_pool = cluster.resourcePool

    # 设置克隆规格
    relospec = vim.vm.RelocateSpec()
    relospec.datastore = datastore
    relospec.pool = resource_pool
    # 正确设置配置参数
    clonespec = vim.vm.CloneSpec()
    vmconf = vim.vm.ConfigSpec()
    vmconf.numCPUs = cpu
    vmconf.numCoresPerSocket = cpu  # 可选：每个 socket 的核数
    vmconf.memoryMB = memory * 1024  # 单位 MB，不需要乘 1024

    # 获取模板的第一个网卡，修改连接状态
    nic_device = None
    for device in template.config.hardware.device:
        if isinstance(device, vim.vm.device.VirtualEthernetCard):
            nic_device = device
            break

    if nic_device:
        nic_spec = vim.vm.device.VirtualDeviceSpec()
        nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        nic_spec.device = nic_device

        # 强制设置连接属性
        nic_spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
        nic_spec.device.connectable.startConnected = True
        nic_spec.device.connectable.allowGuestControl = True
        nic_spec.device.connectable.connected = True

        vmconf.deviceChange = [nic_spec]  # 加入设备变更
    clonespec.config = vmconf

    clonespec.location = relospec
    clonespec.powerOn = power_on
    clonespec.customization = customization_spec  # 在克隆规范中应用自定义规范

    print(f"正在从模板 {template_name} 克隆虚拟机 {vm_name}...")
    task = template.Clone(folder=destfolder, name=vm_name, spec=clonespec)
    try:
        wait_for_task(task)
        print(f"虚拟机 {vm_name} 克隆完成并应用了自定义规范")
        return pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    except Exception as e:
        raise RuntimeError(f"克隆失败: {str(e)}")


def add_disk(vm_name, disk_size, disk_type):
    """
    向虚拟机添加硬盘
    """
    vm = pchelper.get_obj(content, [vim.VirtualMachine], vm_name)
    if vm is None:
        print("未找到虚拟机")
        return
    spec = vim.vm.ConfigSpec()
    # 获取虚拟机上的所有磁盘，设置下一个可用的 unit_number
    unit_number = 0
    controller = None
    for device in vm.config.hardware.device:
        if hasattr(device.backing, 'fileName'):
            unit_number = int(device.unitNumber) + 1
            # unit_number 7 保留给 SCSI 控制器
            if unit_number == 7:
                unit_number += 1
            if unit_number >= 16:
                print("我们不支持这么多磁盘")
                return -1
        if isinstance(device, vim.vm.device.VirtualSCSIController):
            controller = device
    if controller is None:
        print("未找到磁盘 SCSI 控制器！")
        return -1
    # 在此处添加磁盘
    dev_changes = []
    new_disk_kb = int(disk_size) * 1024 * 1024
    disk_spec = vim.vm.device.VirtualDeviceSpec()
    disk_spec.fileOperation = "create"
    disk_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
    disk_spec.device = vim.vm.device.VirtualDisk()
    disk_spec.device.backing = \
        vim.vm.device.VirtualDisk.FlatVer2BackingInfo()
    if disk_type == 'thin':
        disk_spec.device.backing.thinProvisioned = True
    disk_spec.device.backing.diskMode = 'persistent'
    disk_spec.device.unitNumber = unit_number
    disk_spec.device.capacityInKB = new_disk_kb
    disk_spec.device.controllerKey = controller.key
    dev_changes.append(disk_spec)
    spec.deviceChange = dev_changes
    WaitForTask(vm.ReconfigVM_Task(spec=spec))
    print("%sGB 硬盘已添加到 %s" % (disk_size, vm.config.name))
    return 0


parser = cli.Parser()
parser.add_required_arguments(
    cli.Argument.VM_NAME,
    cli.Argument.DISK_SIZE,
    cli.Argument.TEMPLATE,
)
parser.add_custom_argument('--vm_ip', required=True, action='store', help='虚拟机ip 192.168.10.111')
parser.add_custom_argument('--vm_gateway', required=True, action='store', help='虚拟机网关 192.168.10.1')
parser.add_custom_argument('--vm_netmask', required=True, action='store', help='虚拟机掩码 255.255.255.0')
parser.add_custom_argument('--vm_dns', required=True, action='store', help='虚拟机dns 192.168.105.12,192.168.105.11')
parser.add_custom_argument('--vm_vlan_name', required=True, action='store', help='虚拟机的vlan vlan107')
parser.add_custom_argument('--vm_cpu', type=int, required=True, action='store', help='虚拟机的cpu')
parser.add_custom_argument('--vm_memory', type=int, required=True, action='store', help='虚拟机的memory Gb')
parser.add_custom_argument('--vm_note', required=True, action='store', help='虚拟机的备注')

args = parser.get_args()
si = service_instance.connect(args)

content = si.RetrieveContent()

# === 获取目标组件 ===


# === 自定义 IP/网关/DNS 等 ===
from pyVmomi import vim

def create_windows_customization_spec(vm_name: str,
                                      ip: str,
                                      subnet_mask: str,
                                      gateway: list,
                                      dns_servers: list,
                                      domain: str = None,
                                      domain_admin: str = None,
                                      domain_admin_password: str = None,
                                      admin_password: str = None,
                                      time_zone: int = 210  # 中国标准时间
                                      ) -> vim.vm.customization.Specification:
    """
    创建 Windows 自定义规范（CustomizationSpec）
    """
    # 设置网络适配器映射和 IP 配置
    adapter_map = vim.vm.customization.AdapterMapping()
    ip_settings = vim.vm.customization.IPSettings()
    ip_settings.ip = vim.vm.customization.FixedIp(ipAddress=ip)
    ip_settings.subnetMask = subnet_mask
    ip_settings.gateway = gateway
    ip_settings.dnsServerList = dns_servers
    adapter_map.adapter = ip_settings

    # 设置 Sysprep 身份信息
    identity = vim.vm.customization.Sysprep()

    # 设置 userData（包括计算机名、用户名、组织）
    identity.userData = vim.vm.customization.UserData()
    identity.userData.computerName = vim.vm.customization.FixedName(name=vm_name)
    identity.userData.fullName = "Administrator"
    identity.userData.orgName = "MyCompany"

    # 设置 GUI 自动化（登录设置和时区）
    if admin_password is None:
        admin_password = "P@ssw0rd"

    gui_pass = vim.vm.customization.Password()
    gui_pass.plainText = True
    gui_pass.value = admin_password

    identity.guiUnattended = vim.vm.customization.GuiUnattended()
    identity.guiUnattended.autoLogon = False
    identity.guiUnattended.password = gui_pass
    identity.guiUnattended.timeZone = time_zone

    # 设置域或工作组
    identity.identification = vim.vm.customization.Identification()
    if domain and domain_admin and domain_admin_password:
        domain_pass = vim.vm.customization.Password()
        domain_pass.plainText = True
        domain_pass.value = domain_admin_password

        identity.identification.domain = domain
        identity.identification.domainAdmin = domain_admin
        identity.identification.domainAdminPassword = domain_pass
    else:
        identity.identification.joinWorkgroup = "WORKGROUP"

    # 全局 DNS 设置
    global_ip = vim.vm.customization.GlobalIPSettings()
    global_ip.dnsServerList = dns_servers

    # 组装规范对象
    custom_spec = vim.vm.customization.Specification()
    custom_spec.nicSettingMap = [adapter_map]
    custom_spec.identity = identity
    custom_spec.globalIPSettings = global_ip

    return custom_spec
def upload_and_run_powershell_script(si, vm, script_text, remote_path, log_path, username, password, timeout=300):
    from pyVmomi import vim
    import base64
    import time

    creds = vim.vm.guest.NamePasswordAuthentication(username=username, password=password)
    pm = si.content.guestOperationsManager.processManager

    # 1. 编码 PowerShell 脚本为 Base64
    encoded_script = base64.b64encode(script_text.encode('utf-8')).decode('utf-8')

    # 2. 使用 Set-Content 写入解码脚本文件（更可靠）
    # 注意转义双引号和嵌套结构
    write_script_cmd = (
        f'powershell.exe -Command "'
        f'$b64 = \\"{encoded_script}\\"; '
        f'$bytes = [Convert]::FromBase64String($b64); '
        f'$text = [System.Text.Encoding]::UTF8.GetString($bytes); '
        f'Set-Content -Path \\"{remote_path}\\" -Value $text -Encoding UTF8"'
    )

    # write_script_cmd = (
    #     f"powershell.exe -Command "
    #     f"echo '{script_text}' > {remote_path}'"
    # )
    # 3. 执行 .ps1 脚本并重定向输出
    run_script_cmd = f'powershell.exe -ExecutionPolicy Bypass -File "{remote_path}" > "{log_path}" 2>&1'

    # 4. 拼接为完整的 cmd.exe 命令
    full_cmd = f'{write_script_cmd} && {run_script_cmd}'

    spec = vim.vm.guest.ProcessManager.ProgramSpec(
        programPath="cmd.exe",
        arguments=f"/c {full_cmd}"
    )

    pid = pm.StartProgramInGuest(vm, creds, spec)
    print(f"执行进程 PID: {pid}")

    # 等待执行结束
    start_time = time.time()
    while True:
        proc = pm.ListProcessesInGuest(vm, creds, [pid])[0]
        if proc.exitCode is not None:
            print(f"脚本执行结束，退出码: {proc.exitCode}")
            return proc.exitCode
        if time.time() - start_time > timeout:
            print("执行超时")
            return None
        time.sleep(2)

def check_vm_tool(vm, timeout=30):
    temp = 0
    while True:
        time.sleep(1)
        temp = temp + 1
        try:
            print(f"tool状态检查中第{temp}次")
            if vm.guest.toolsStatus == "toolsOk":
                break
        except Exception as e:
            print(f"错误{e}")
            break
        if temp == timeout:
            print(f"超时")
            break
def cidr_to_netmask(cidr):
    cidr = int(cidr)  # <== 添加这一行
    bits = 0xffffffff ^ (1 << 32 - cidr) - 1
    return "{}.{}.{}.{}".format((bits >> 24) & 0xff, (bits >> 16) & 0xff, (bits >> 8) & 0xff, bits & 0xff)


# 示例用法
subnet_mask = cidr_to_netmask(args.vm_netmask)  # 24 => '255.255.255.0'


dns_list = args.vm_dns.split(',')  # 比如 "192.168.105.12,192.168.105.11"
# === 克隆配置 ===
win_custom_spec = create_windows_customization_spec(
    vm_name=args.vm_name,
    ip=args.vm_ip,
    subnet_mask=subnet_mask,
    gateway=[args.vm_gateway],
    dns_servers=dns_list,
    domain=None,
    domain_admin=None,
    domain_admin_password=None,
    admin_password=None,
    time_zone=210
)
# 克隆虚拟机
try:
    vm = clone_vm_with_customization(
        content,
        args.template,
        args.vm_name,
        'DC-A4-XM-ZD-DataCenter',
        None,
        'A4-XM-ZD-56.30-SATA-DS01',
        'DC-A4-XM-ZD-Cluster01',
        None,
        True,
        None,
        win_custom_spec,
        args.vm_cpu,
        args.vm_memory
    )
    print(f"虚拟机 {args.vm_name} 创建成功")
except Exception as e:
    print(f"错误: {str(e)}")
# === 挂载新硬盘 ===
add_disk(args.vm_name, args.disk_size, 'thin')

# 指定vlan
update_nic_network(si, args.vm_name, args.vm_vlan_name)

time.sleep(120)



script = (
    'Get-Disk | Where-Object PartitionStyle -Eq "RAW" | '
    'Initialize-Disk -PartitionStyle MBR -PassThru | '
    'New-Partition -UseMaximumSize -AssignDriveLetter | '
    'Format-Volume -FileSystem NTFS -NewFileSystemLabel "DataDisk" -Confirm:$false'
)

vm_obj = pchelper.get_obj(content, [vim.VirtualMachine], args.vm_name)
if vm_obj is None:
    print("未找到虚拟机")
set_note(vm_obj, args.vm_note)
check_vm_tool(vm_obj)
#run_script_in_vm(si, vm_obj, script, username='Administrator', password='P@ssw0rd', os_type='windows')
upload_and_run_powershell_script(si,vm_obj,script,"c:/Windows/Temp/temp.ps1","c:/logs.txt","Administrator","P@ssw0rd")

```

```python
# VMware vSphere Python SDK Community Samples Addons
# Copyright (c) 2014-2021 VMware, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
This module implements simple helper functions for python samples
"""

# import argparse
# self._parser = argparse.ArgumentParser(description='与 vCenter 通信的参数')
from gooey import GooeyParser
import getpass

__author__ = "VMware, Inc."


class Parser:
    """
    Samples specific argument parser.
    Wraps argparse to ease the setup of argument requirements for the samples.

    Example:
        parser = cli.Parser()
        parser.add_required_arguments(cli.Argument.VM_NAME)
        parser.add_optional_arguments(cli.Argument.DATACENTER_NAME, cli.Argument.NIC_NAME)
        parser.add_custom_argument(
            '--disk-number', required=True, help='Disk number to change mode.')
        args = parser.get_args()
    """

    def __init__(self):
        """
        Defines two arguments groups.
        One for the standard arguments and one for sample specific arguments.
        The standard group cannot be extended.
        """
        # import argparse
        # self._parser = argparse.ArgumentParser(description='与 vCenter 通信的参数')
        from gooey import GooeyParser
        self._parser = GooeyParser(description='与 vCenter 通信的参数')
        self._standard_args_group = self._parser.add_argument_group('标准参数')
        self._specific_args_group = self._parser.add_argument_group('样本特定参数')

        # because -h is reserved for 'help' we use -s for service
        self._standard_args_group.add_argument('-s', '--host',
                                               required=True,
                                               action='store',
                                               help='要连接的 vSphere 服务地址')

        # because we want -p for password, we use -o for port
        self._standard_args_group.add_argument('-o', '--port',
                                               type=int,
                                               default=443,
                                               action='store',
                                               help='连接到 vSphere 服务时使用的端口号')

        self._standard_args_group.add_argument('-u', '--user',
                                               required=True,
                                               action='store',
                                               help='连接主机时使用的用户名')

        self._standard_args_group.add_argument('-p', '--password',
                                               required=False,
                                               action='store',
                                               widget='PasswordField',
                                               help='连接主机时使用的密码')

        self._standard_args_group.add_argument('-nossl', '--disable-ssl-verification',
                                               required=False,
                                               action='store_true',
                                               help='禁用 SSL 主机证书验证')

    def get_args(self):
        """
        Supports the command-line arguments needed to form a connection to vSphere.
        """
        args = self._parser.parse_args()
        return self._prompt_for_password(args)

    def _add_sample_specific_arguments(self, is_required: bool, *args):
        """
        Add an argument to the "sample specific arguments" group
        Requires a predefined argument from the Argument class.
        """
        for arg in args:
            name_or_flags = arg["name_or_flags"]
            options = arg["options"]
            options["required"] = is_required
            self._specific_args_group.add_argument(*name_or_flags, **options)

    def add_required_arguments(self, *args):
        """
        Add a required argument to the "sample specific arguments" group
        Requires a predefined argument from the Argument class.
        """
        self._add_sample_specific_arguments(True, *args)

    def add_optional_arguments(self, *args):
        """
        Add an optional argument to the "sample specific arguments" group.
        Requires a predefined argument from the Argument class.
        """
        self._add_sample_specific_arguments(False, *args)

    def add_custom_argument(self, *name_or_flags, **options):
        """
        Uses ArgumentParser.add_argument() to add a full definition of a command line argument
        to the "sample specific arguments" group.
        https://docs.python.org/3/library/argparse.html#the-add-argument-method
        """
        self._specific_args_group.add_argument(*name_or_flags, **options)

    def set_epilog(self, epilog):
        """
        Text to display after the argument help
        """
        self._parser.epilog = epilog

    def _prompt_for_password(self, args):
        """
        if no password is specified on the command line, prompt for it
        """
        if not args.password:
            args.password = getpass.getpass(
                prompt='"--password" not provided! Please enter password for host %s and user %s: '
                       % (args.host, args.user))
        return args


class Argument:
    """
    Predefined arguments to use in the Parser

    Example:
        parser = cli.Parser()
        parser.add_optional_arguments(cli.Argument.VM_NAME)
        parser.add_optional_arguments(cli.Argument.DATACENTER_NAME, cli.Argument.NIC_NAME)
    """

    def __init__(self):
        pass

    UUID = {
        'name_or_flags': ['--uuid'],
        'options': {'action': 'store', 'help': 'UUID of an entity (VirtualMachine or HostSystem)'}
    }
    VM_NAME = {
        'name_or_flags': ['-v', '--vm-name'],
        'options': {'action': 'store', 'help': 'Name of the vm'}
    }
    VM_IP = {
        'name_or_flags': ['--vm-ip'],
        'options': {'action': 'store', 'help': 'IP of the vm'}
    }
    VM_MAC = {
        'name_or_flags': ['-mac', '--vm-mac'],
        'options': {'action': 'store', 'help': 'Mac address of the VM'}
    }
    VM_USER = {
        'name_or_flags': ['--vm-user'],
        'options': {'action': 'store', 'help': 'virtual machine user name'}
    }
    VM_PASS = {
        'name_or_flags': ['--vm-password'],
        'options': {'action': 'store', 'help': 'virtual machine password'}
    }
    ESX_NAME = {
        'name_or_flags': ['-e', '--esx-name'],
        'options': {'action': 'store', 'help': 'Esx name'}
    }
    ESX_IP = {
        'name_or_flags': ['--esx-ip'],
        'options': {'action': 'store', 'help': 'Esx ip'}
    }
    ESX_NAME_REGEX = {
        'name_or_flags': ['--esx-name-regex'],
        'options': {'action': 'store', 'help': 'Esx name regex'}
    }
    DNS_NAME = {
        'name_or_flags': ['--dns-name'],
        'options': {'action': 'store', 'help': 'DNS name'}
    }
    NAME = {
        'name_or_flags': ['-n', '--name'],
        'options': {'action': 'store', 'help': 'Name of the entity'}
    }
    NEW_NAME = {
        'name_or_flags': ['-r', '--new-name'],
        'options': {'action': 'store', 'help': 'New name of the entity.'}
    }
    DATACENTER_NAME = {
        'name_or_flags': ['--datacenter-name'],
        'options': {'action': 'store', 'help': 'Datacenter name'}
    }
    DATASTORE_NAME = {
        'name_or_flags': ['--datastore-name'],
        'options': {'action': 'store', 'help': 'Datastore name'}
    }
    CLUSTER_NAME = {
        'name_or_flags': ['--cluster-name'],
        'options': {'action': 'store', 'help': 'Cluster name'}
    }
    FOLDER_NAME = {
        'name_or_flags': ['--folder-name'],
        'options': {'action': 'store', 'help': 'Folder name'}
    }
    TEMPLATE = {
        'name_or_flags': ['--template'],
        'options': {'action': 'store', 'help': 'Name of the template/VM'}
    }
    VMFOLDER = {
        'name_or_flags': ['--vm-folder'],
        'options': {'action': 'store', 'help': 'Name of the VMFolder'}
    }
    DATASTORECLUSTER_NAME = {
        'name_or_flags': ['--datastorecluster-name'],
        'options': {'action': 'store', 'help': 'Datastorecluster (DRS Storagepod)'}
    }
    RESOURCE_POOL = {
        'name_or_flags': ['--resource-pool'],
        'options': {'action': 'store', 'help': 'Resource pool name'}
    }
    POWER_ON = {
        'name_or_flags': ['--power-on'],
        'options': {'action': 'store_true', 'help': 'power on the VM'}
    }
    LANGUAGE = {
        'name_or_flags': ['--language'],
        'options': {'action': 'store', 'default': 'English', 'help': 'Language your vcenter used.'}
    }
    VIHOST = {
        'name_or_flags': ['--vihost'],
        'options': {'action': 'store',
                    'help': 'Name/ip address of ESXi host as seen in vCenter Server'}
    }
    DVS_PORT_GROUP_NAME = {
        'name_or_flags': ['--dvs-pg-name'],
        'options': {'action': 'store', 'help': '"Name of the distributed port group'}
    }
    DVS_NAME = {
        'name_or_flags': ['--dvs-name'],
        'options': {'action': 'store', 'help': 'Name of the distributed virtual switch'}
    }
    OPAQUE_NETWORK_NAME = {
        'name_or_flags': ['--opaque-network-name'],
        'options': {'action': 'store', 'help': 'Name of an opaque network'}
    }
    FIRST_CLASS_DISK_NAME = {
        'name_or_flags': ['--fcd-name'],
        'options': {'action': 'store', 'help': 'First Class Disk name'}
    }
    DISK_TYPE = {
        'name_or_flags': ['--disk-type'],
        'options': {'action': 'store',
                    'default': 'thin', 'choices': ['thick', 'thin'], 'help': 'thick or thin'}
    }
    DISK_SIZE = {
        'name_or_flags': ['--disk-size'],
        'options': {'action': 'store', 'help': 'disk size, in GB, to add to the VM'}
    }
    PORT_GROUP = {
        'name_or_flags': ['-g', '--port-group'],
        'options': {'action': 'store', 'help': 'Name of port group'}
    }
    NETWORK_NAME = {
        'name_or_flags': ['--network-name'],
        'options': {'action': 'store', 'help': 'Name of network'}
    }
    VSWITCH_NAME = {
        'name_or_flags': ['-w', '--vswitch-name'],
        'options': {'action': 'store', 'help': 'vSwitch name'}
    }
    LOCAL_FILE_PATH = {
        'name_or_flags': ['--local-file-path'],
        'options': {'action': 'store', 'help': 'Local disk path to file'}
    }
    REMOTE_FILE_PATH = {
        'name_or_flags': ['--remote-file-path'],
        'options': {'action': 'store', 'help': 'Path on datastore or vm or other entity to file'}
    }
    VLAN_ID = {
        'name_or_flags': ['--vlan-id'],
        'options': {'action': 'store', 'help': 'Vlan ID'}
    }
    DEVICE_NAME = {
        'name_or_flags': ['--device-name'],
        'options': {'action': 'store', 'help': 'The device name. Might look like '
                                               '"/vmfs/devices/disks/naa.*". '
                                               'See vim.vm.device.VirtualDisk.'
                                               'RawDiskMappingVer1BackingInfo documentation.'}}
    DISK_MODE = {
        'name_or_flags': ['--disk-mode'],
        'options': {'action': 'store',
                    'default': 'independent_persistent',
                    'choices': [
                        'append',
                        'independent_nonpersistent',
                        'independent_persistent',
                        'nonpersistent',
                        'persistent',
                        'undoable'],
                    'help': 'See vim.vm.device.VirtualDiskOption.DiskMode documentation.'}}

    COMPATIBILITY_MODE = {
        'name_or_flags': ['--disk-compatibility-mode'],
        'options': {'action': 'store',
                    'default': 'virtualMode',
                    'choices': ['physicalMode', 'virtualMode'],
                    'help': 'See vim.vm.device.VirtualDiskOption.CompatibilityMode documentation.'}}

    ISO = {
        'name_or_flags': ['--iso'],
        'options': {'action': 'store',
                    'help': 'ISO to use in test. Use datastore path format. '
                            'E.g. [datastore1] path/to/file.iso'}
    }
    NIC_NAME = {
        'name_or_flags': ['--nic-name'],
        'options': {'action': 'store', 'help': 'NIC number.'}
    }
    NIC_UNIT_NUMBER = {
        'name_or_flags': ['--nic-unitnumber'],
        'options': {'action': 'store', 'type': int, 'help': 'NIC number.'}
    }
    NIC_STATE = {
        'name_or_flags': ['--nic-state'],
        'options': {'action': 'store', 'choices': ['delete', 'disconnect', 'connect'],
                    'help': 'NIC number.'}
    }
    VMDK_PATH = {
        'name_or_flags': ['--vmdk-path'],
        'options': {'action': 'store', 'help': 'Path of the VMDK file.'}
    }
    OVA_PATH = {
        'name_or_flags': ['--ova-path'],
        'options': {'action': 'store', 'help': 'Path to the OVA file.'}
    }
    OVF_PATH = {
        'name_or_flags': ['--ovf-path'],
        'options': {'action': 'store', 'help': 'Path to the OVF file.'}
    }
    DATE = {
        'name_or_flags': ['--date'],
        'options': {'action': 'store', 'help': 'Date and time with the format d/m/Y H:M'}
    }
    MINUTES = {
        'name_or_flags': ['--minutes'],
        'options': {'action': 'store', 'help': 'time in minutes'}
    }
    MESSAGE = {
        'name_or_flags': ['-m', '--message'],
        'options': {'action': 'store', 'help': 'Message'}
    }

    SNAPSHOT_OPERATION = {
        'name_or_flags': ['-op', '--snapshot-operation'],
        'options': {'action': 'store',
                    'choices':
                        ['create', 'remove', 'revert', 'list_all', 'list_current', 'remove_all'],
                    'help': 'Snapshot operation'}
    }
    SNAPSHOT_NAME = {
        'name_or_flags': ['--snapshot-name'],
        'options': {'action': 'store', 'help': 'Snapshot name'}
    }
    STORAGE_POLICY_NAME = {
        'name_or_flags': ['--storage-policy-name'],
        'options': {'action': 'store', 'metavar': 'string', 'help': 'Storage policy name'}
    }
    ASSUME_INPUT = {
        'name_or_flags': ['--assume-input'],
        'options': {'action': 'store', 'help': 'Assume user input'}
    }
    SSL_KEY = {
        'name_or_flags': ['--ssl-key'],
        'options': {'action': 'store', 'help': 'absolute location of the private key file'}
    }
    SSL_CERT = {
        'name_or_flags': ['--ssl-cert'],
        'options': {'action': 'store', 'help': 'absolute location of the certificate file'}
    }


def prompt_y_n_question(question, default="no"):
    """ based on:
        http://code.activestate.com/recipes/577058/
    :param question: Question to ask
    :param default: No
    :return: True/False
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("Invalid default answer: '{}'".format(default))

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please, respond with 'yes' or 'no' or 'y' or 'n'.")

```

```python
"""
This module implements simple helper functions for managing service instance objects
"""
__author__ = "VMware, Inc."

import atexit
from pyVim.connect import SmartConnect, Disconnect


def connect(args):
    """
    Determine the most preferred API version supported by the specified server,
    then connect to the specified server using that API version, login and return
    the service instance object.
    """

    service_instance = None

    # form a connection...
    try:
        if args.disable_ssl_verification:
            service_instance = SmartConnect(host=args.host,
                                            user=args.user,
                                            pwd=args.password,
                                            port=args.port,
                                            disableSslCertValidation=True)
        else:
            service_instance = SmartConnect(host=args.host,
                                            user=args.user,
                                            pwd=args.password,
                                            port=args.port)

        # doing this means you don't need to remember to disconnect your script/objects
        atexit.register(Disconnect, service_instance)
    except IOError as io_error:
        print(io_error)

    if not service_instance:
        raise SystemExit("Unable to connect to host with supplied credentials.")

    return service_instance

```

```python
"""
Property Collector helper module.
"""

import pyVmomi


# Shamelessly borrowed from:
# https://github.com/dnaeon/py-vconnector/blob/master/src/vconnector/core.py
def collect_properties(si, view_ref, obj_type, path_set=None,
                       include_mors=False):
    """
    Collect properties for managed objects from a view ref

    Check the vSphere API documentation for example on retrieving
    object properties:

        - http://goo.gl/erbFDz

    Args:
        si          (ServiceInstance): ServiceInstance connection
        view_ref (pyVmomi.vim.view.*): Starting point of inventory navigation
        obj_type      (pyVmomi.vim.*): Type of managed object
        path_set               (list): List of properties to retrieve
        include_mors           (bool): If True include the managed objects
                                       refs in the result

    Returns:
        A list of properties for the managed objects

    """
    collector = si.content.propertyCollector

    # Create object specification to define the starting point of
    # inventory navigation
    obj_spec = pyVmomi.vmodl.query.PropertyCollector.ObjectSpec()
    obj_spec.obj = view_ref
    obj_spec.skip = True

    # Create a traversal specification to identify the path for collection
    traversal_spec = pyVmomi.vmodl.query.PropertyCollector.TraversalSpec()
    traversal_spec.name = 'traverseEntities'
    traversal_spec.path = 'view'
    traversal_spec.skip = False
    traversal_spec.type = view_ref.__class__
    obj_spec.selectSet = [traversal_spec]

    # Identify the properties to the retrieved
    property_spec = pyVmomi.vmodl.query.PropertyCollector.PropertySpec()
    property_spec.type = obj_type

    if not path_set:
        property_spec.all = True

    property_spec.pathSet = path_set

    # Add the object and property specification to the
    # property filter specification
    filter_spec = pyVmomi.vmodl.query.PropertyCollector.FilterSpec()
    filter_spec.objectSet = [obj_spec]
    filter_spec.propSet = [property_spec]

    # Retrieve properties
    props = collector.RetrieveContents([filter_spec])

    data = []
    for obj in props:
        properties = {}
        for prop in obj.propSet:
            properties[prop.name] = prop.val

        if include_mors:
            properties['obj'] = obj.obj

        data.append(properties)
    return data


def get_container_view(si, obj_type, container=None):
    """
    Get a vSphere Container View reference to all objects of type 'obj_type'

    It is up to the caller to take care of destroying the View when no longer
    needed.

    Args:
        obj_type (list): A list of managed object types

    Returns:
        A container view ref to the discovered managed objects
    """
    if not container:
        container = si.content.rootFolder

    view_ref = si.content.viewManager.CreateContainerView(
        container=container,
        type=obj_type,
        recursive=True
    )
    return view_ref


def search_for_obj(content, vim_type, name, folder=None, recurse=True):
    """
    Search the managed object for the name and type specified

    Sample Usage:

    get_obj(content, [vim.Datastore], "Datastore Name")
    """
    if folder is None:
        folder = content.rootFolder

    obj = None
    container = content.viewManager.CreateContainerView(folder, vim_type, recurse)

    for managed_object_ref in container.view:
        if managed_object_ref.name == name:
            obj = managed_object_ref
            break
    container.Destroy()
    return obj


def get_all_obj(content, vim_type, folder=None, recurse=True):
    """
    Search the managed object for the name and type specified

    Sample Usage:

    get_obj(content, [vim.Datastore], "Datastore Name")
    """
    if not folder:
        folder = content.rootFolder

    obj = {}
    container = content.viewManager.CreateContainerView(folder, vim_type, recurse)

    for managed_object_ref in container.view:
        obj[managed_object_ref] = managed_object_ref.name

    container.Destroy()
    return obj


def get_obj(content, vim_type, name, folder=None, recurse=True):
    """
    Retrieves the managed object for the name and type specified
    Throws an exception if of not found.

    Sample Usage:

    get_obj(content, [vim.Datastore], "Datastore Name")
    """
    obj = search_for_obj(content, vim_type, name, folder, recurse)
    if not obj:
        raise RuntimeError("Managed Object " + name + " not found.")
    return obj

```

