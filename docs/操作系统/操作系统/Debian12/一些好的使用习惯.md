### <font style="color:rgb(34, 34, 34);">将 </font>`/data`<font style="color:rgb(34, 34, 34);"> 作为工作目录</font>
```plain
mkdir /data
```

+ <font style="color:rgb(34, 34, 34);">编译工作目录为</font><font style="color:rgb(34, 34, 34);"> </font>`/data/compile`
+ <font style="color:rgb(34, 34, 34);">网页目录为 </font>`/data/www`

### `/opt`<font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">目录</font>
<font style="color:rgb(34, 34, 34);">所有单执行文件的应用, 或者各类配置文件, 统一放置到此处, 后面迁移非常方便</font>

## <font style="color:rgb(34, 34, 34);">Docker</font>
<font style="color:rgb(34, 34, 34);">官方参考文档:</font><font style="color:rgb(34, 34, 34);"> </font>[Debian | Docker Docs](https://docs.docker.com/engine/install/debian/#installation-methods)

```bash
# Uninstall old versions
for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done

# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

# Install the Docker packages.
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# Verify that the installation is successful by running the hello-world image
sudo docker run hello-world
```

### <font style="color:rgb(34, 34, 34);">安全实践:</font><font style="color:rgb(34, 34, 34);"> </font>**<font style="color:red;">Docker 干预 iptables 导致异常暴露端口的问题</font>**
<font style="color:rgb(34, 34, 34);">安装 Docker 后, 务必编辑 </font>`/etc/docker/daemon.json`<font style="color:rgb(34, 34, 34);">(没有就新建一个), 设置 </font>`ip`<font style="color:rgb(34, 34, 34);"> 为 </font>`127.0.0.1`<font style="color:rgb(34, 34, 34);">, 防止 docker 自己修改了 iptable 导致 ufw 失效(或者说不受 ufw 管了).</font>

<font style="color:rgb(34, 34, 34);">国外服务器自行替换 dns 为 </font>`<font style="color:rgb(34, 34, 34);">1.1.1.1</font>`<font style="color:rgb(34, 34, 34);">, </font>`<font style="color:rgb(34, 34, 34);">8.8.8.8</font>`<font style="color:rgb(34, 34, 34);">:</font>

```bash
cat <<EOF > /etc/docker/daemon.json
{
    "dns":[
        "119.29.29.29",
        "223.5.5.5"
    ],
    "ip":"127.0.0.1"
}
EOF
```

### <font style="color:rgb(34, 34, 34);">配置 Docker 容器的 IPv6 支持</font>
```bash
cat <<'EOF' > /etc/docker/daemon.json
{
    "ipv6":true,
    "fixed-cidr-v6": "2001:db8::/64",
    "ip":"127.0.0.1"
}
EOF
```

<font style="color:rgb(34, 34, 34);">执行 </font>`<font style="color:rgb(34, 34, 34);">systemctl daemon-reload && systemctl restart docker</font>`<font style="color:rgb(34, 34, 34);"> 重启 Docker.</font>

+ <font style="color:rgb(34, 34, 34);">已知对于部分机器, 若已 DD 系统, 且开启 IPv6, 会出路由问题导致机器失联.</font>

<font style="color:rgb(34, 34, 34);">需要手动配置路由, 如修改</font><font style="color:rgb(34, 34, 34);"> </font>`/etc/network/interfaces`<font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">(假设网卡名为</font><font style="color:rgb(34, 34, 34);"> </font>`eth0`<font style="color:rgb(34, 34, 34);">):</font>

```plain
auto eth0

iface eth0 inet dhcp

iface eth0 inet6 dhcp
  post-up ip -6 route add default dev eth0 metric 100
```

### <font style="color:rgb(34, 34, 34);">更改 Docker 默认的内网网段</font>
<font style="color:rgb(34, 34, 34);">毕竟有时候会和实际的内网冲突.</font>

```bash
cat <<'EOF' > /etc/docker/daemon.json
{
    "bip": "192.168.233.1/24",
    "fixed-cidr": "192.168.233.0/25",
    "mtu": 1500,
    "default-gateway": "192.168.233.254",
    "dns":[
        "223.5.5.5",
        "223.6.6.6"
    ],
    "ipv6":true,
    "fixed-cidr-v6": "2001:db8::/64",
    "ip":"127.0.0.1"
}
EOF
```

`bip`<font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">就是宿主机地址,</font><font style="color:rgb(34, 34, 34);"> </font>`fixed-cidr`<font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">就是你想要的内网 CIDR,</font><font style="color:rgb(34, 34, 34);"> </font>`default-gateway`<font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">就是默认路由地址. 这三个</font><font style="color:rgb(34, 34, 34);"> </font>**<font style="color:rgb(34, 34, 34);">缺一不可</font>**<font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">(血泪教训: 没写</font><font style="color:rgb(34, 34, 34);"> </font>`default-gateway`<font style="color:rgb(34, 34, 34);">, 导致容器内无法访问外部网络)</font>

<font style="color:rgb(34, 34, 34);">执行 </font>`systemctl daemon-reload && systemctl restart docker`<font style="color:rgb(34, 34, 34);"> 重启 Docker.</font>

### <font style="color:rgb(34, 34, 34);">代理 (含 Docker 宿主本体及容器内部)</font>
```bash
# 自己根据实际情况修改
export DOCKER_PROXY="http://127.0.0.1:11100"
export DOCKER_NO_PROXY="localhost,127.0.0.1,.edu.cn"

sudo mkdir -p /etc/systemd/system/docker.service.d

cat <<EOF > /etc/systemd/system/docker.service.d/proxy.conf
[Service]
Environment="HTTP_PROXY=$DOCKER_PROXY"
Environment="HTTPS_PROXY=$DOCKER_PROXY"
Environment="NO_PROXY=$DOCKER_NO_PROXY"
EOF

mkdir ~/.docker
cat <<EOF > ~/.docker/config.json
{
    "proxies": {
        "default": {
            "httpProxy": "$DOCKER_PROXY",
            "httpsProxy": "$DOCKER_PROXY",
            "noProxy": "$DOCKER_NO_PROXY"
        }
    }
}
EOF
```

<font style="color:rgb(34, 34, 34);">执行 </font>`systemctl daemon-reload && systemctl restart docker`<font style="color:rgb(34, 34, 34);"> 重启 Docker.</font>

## <font style="color:rgb(34, 34, 34);">Nginx (编译安装)</font>
<font style="color:rgb(34, 34, 34);">为了最佳性能, 以及我们需要 brotli, 一般都编译安装 Nginx.</font>

```bash
# 安装必要依赖
apt install -y build-essential cmake libpcre3 libpcre3-dev libpcre2-dev zlib1g-dev openssl libssl-dev libxml2-dev libxslt1-dev libgd-dev libgeoip-dev libgoogle-perftools-dev libperl-dev perl-base perl

# 使用 mimalloc, 性能更佳
apt install libmimalloc2.0
cd /usr/lib && ln ./x86_64-linux-gnu/libmimalloc.so.2.0 libmimalloc.so

# Nginx 版本, 目前为 1.27.4, 参见 https://freenginx.org/
export NGINX_VERSION="1.27.4"

# 新建编译用工作目录(大概率还没有)
mkdir /data
mkdir /data/compile
mkdir /data/compile/nginx

export COMPILE_PATH="/data/compile/nginx"

# 进入编译 Nginx 用的工作目录
cd $COMPILE_PATH

# 我们使用开源版本的 Nginx, 叫 freenginx.
wget https://freenginx.org/download/freenginx-$NGINX_VERSION.tar.gz
tar -zxvf freenginx-$NGINX_VERSION.tar.gz
rm freenginx-$NGINX_VERSION.tar.gz
mv freenginx-$NGINX_VERSION src

# 下载 Brotli
git clone https://github.com/google/ngx_brotli && cd ngx_brotli && git submodule update --init && cd -

# configure, 可以根据实际需要改动, 不过应该也不用
cd src
./configure \
--prefix=/etc/nginx \
--sbin-path=/usr/sbin/nginx \
--modules-path=/usr/lib/nginx/modules \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--pid-path=/var/run/nginx.pid \
--lock-path=/var/run/nginx.lock \
--http-client-body-temp-path=/var/cache/nginx/client_temp \
--http-proxy-temp-path=/var/cache/nginx/proxy_temp \
--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
--http-scgi-temp-path=/var/cache/nginx/scgi_temp \
--user=nginx \
--group=nginx \
--with-threads \
--with-file-aio \
--with-http_ssl_module \
--with-http_v2_module \
--with-http_v3_module \
--with-http_realip_module \
--with-http_addition_module \
--with-http_xslt_module \
--with-http_image_filter_module \
--with-http_geoip_module \
--with-http_sub_module \
--with-http_dav_module \
--with-http_flv_module \
--with-http_mp4_module \
--with-http_gunzip_module \
--with-http_gzip_static_module \
--with-http_auth_request_module \
--with-http_random_index_module \
--with-http_secure_link_module \
--with-http_degradation_module \
--with-http_slice_module \
--with-http_stub_status_module \
--with-http_perl_module \
--with-mail \
--with-mail_ssl_module \
--with-stream \
--with-stream_ssl_module \
--with-stream_realip_module \
--with-stream_geoip_module \
--with-stream_ssl_preread_module \
--add-module=$COMPILE_PATH/ngx_brotli \
--with-compat \
--with-cc-opt='-g0 -O3 -fstack-reuse=all -fdwarf2-cfi-asm -fplt -fno-trapv -fno-exceptions -fno-unwind-tables -fno-asynchronous-unwind-tables -fno-stack-check -fno-stack-clash-protection -fno-stack-protector -fcf-protection=none -fno-split-stack -fno-sanitize=all -fno-instrument-functions'

# 编译, CPU 有几核就 -j 几
make -j2

# 安装到指定目录
make install

# 配置 systemd 持久化
cat <<'TEXT' > /etc/systemd/system/nginx.service
[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking

Restart=always
RestartSec=15
StartLimitInterval=0

User=root

Environment="LD_PRELOAD=/usr/lib/libmimalloc.so"

ExecStartPre=/bin/rm -rf /dev/shm/nginx
ExecStartPre=/bin/mkdir /dev/shm/nginx
ExecStartPre=/bin/chmod 711 /dev/shm/nginx
ExecStartPre=/bin/mkdir /dev/shm/nginx/tcmalloc
ExecStartPre=/bin/chmod 0777 /dev/shm/nginx/tcmalloc
ExecStart=/usr/sbin/nginx
ExecReload=/usr/sbin/nginx -s reload
ExecStop=/usr/sbin/nginx -s stop
ExecStopPost=/bin/rm -rf /dev/shm/nginx

PrivateTmp=true

[Install]
WantedBy=multi-user.target
TEXT

# 配置文件参考
# 备份一下, 养成习惯
mv /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak

# 根据实际情况修改再执行!!!
cat <<'TEXT' > /etc/nginx/nginx.conf
# daemon off;
# pid /run/nginx/nginx.pid;
user nginx nginx;
worker_processes auto;
worker_cpu_affinity auto;
worker_priority -20;
worker_rlimit_nofile 51200;

events
{
    use epoll;
    worker_connections 10240;
    multi_accept on;
}

http
{
    include mime.types;
    # set_real_ip_from 0.0.0.0/0;
    # 有用 Cloudflare CDN, 解除注释下一行
    # real_ip_header CF-Connecting-IP;

    default_type  application/octet-stream;
    charset utf-8;

    http2 on;

    log_format details '[$time_local][$status]|[Client] "$remote_addr" |[Host] "$host" |[Refer] "$http_referer" |[UA] "$http_user_agent" |[REQ] "$request" |[CONNECT] "$connection_requests" |[TIME] "$request_time" |[LENGTH] "$bytes_sent" |[UPSTREAM] "$upstream_addr" |[U_HEAD_TIME] "$upstream_header_time" |[U_CON_TIME] "$upstream_connect_time" |[U_RSP_TIME] "$upstream_response_time" |[U_STATUS] "$upstream_status" |[U_LENGTH] "$upstream_response_length"';
    log_format details_pp '[$time_local][$status]|[Client] "$proxy_protocol_addr" |[Host] "$host" |[Refer] "$http_referer" |[UA] "$http_user_agent" |[REQ] "$request" |[CONNECT] "$connection_requests" |[TIME] "$request_time" |[LENGTH] "$bytes_sent" |[UPSTREAM] "$upstream_addr" |[U_HEAD_TIME] "$upstream_header_time" |[U_CON_TIME] "$upstream_connect_time" |[U_RSP_TIME] "$upstream_response_time" |[U_STATUS] "$upstream_status" |[U_LENGTH] "$upstream_response_length"';

    server_names_hash_bucket_size 512;
    client_header_buffer_size 32k;
    large_client_header_buffers 4 32k;
    client_max_body_size 50m;

    # Perf
    access_log off;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    reset_timedout_connection on;
    client_body_timeout 10;
    send_timeout 2;
    keepalive_timeout 60;

    # SSL
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_ecdh_curve X25519:P-256:P-384:P-224:P-521;
    ssl_dhparam /etc/nginx/certs/dhparam.pem;
    ssl_session_cache shared:MozSSL:30m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;
    ssl_stapling on;
    ssl_stapling_verify on;
    # 境外机器, 修改 `223.5.5.5 223.6.6.6` 为 `1.1.1.1 1.0.0.1`
    resolver 223.5.5.5 223.6.6.6 valid=60s;
    resolver_timeout 2s;
    ssl_early_data on;
    proxy_set_header Early-Data $ssl_early_data;
    ssl_buffer_size 8k;

    ##
    # Connection header for WebSocket reverse proxy
    ##
    map $http_upgrade $connection_upgrade {
      default upgrade;
      '' close;
    }

    # fastcgi
    fastcgi_connect_timeout 300;
    fastcgi_send_timeout 300;
    fastcgi_read_timeout 300;
    fastcgi_buffer_size 64k;
    fastcgi_buffers 4 64k;
    fastcgi_busy_buffers_size 128k;
    fastcgi_temp_file_write_size 256k;
    fastcgi_intercept_errors on;

    # compress
    gzip on;
    gzip_min_length 1k;
    gzip_buffers 4 16k;
    gzip_http_version 1.1;
    gzip_comp_level 6;
    gzip_types
        # text/html
        text/css
        text/javascript
        text/xml
        text/plain
        text/x-component
        application/javascript
        application/x-javascript
        application/json
        application/xml
        application/rss+xml
        application/atom+xml
        font/truetype
        font/opentype
        application/vnd.ms-fontobject
        image/svg+xml;
    gzip_vary on;
    gzip_proxied expired no-cache no-store private auth;
    gzip_disable "MSIE [1-6]\.";
    brotli on;
    brotli_comp_level 6;
    brotli_types
        # text/html
        text/css
        text/javascript
        text/xml
        text/plain
        text/x-component
        application/javascript
        application/x-javascript
        application/json
        application/xml
        application/rss+xml
        application/atom+xml
        font/truetype
        font/opentype
        application/vnd.ms-fontobject
        image/svg+xml;

    # Others
    limit_conn_zone $binary_remote_addr zone=perip:10m;
    limit_conn_zone $server_name zone=perserver:10m;
    server_tokens off;

    # Nginx 对 QUIC 支持不佳, 我选择关掉, 如果你想试试, 下面四行解除注释.
    # http3 on;
    # http3_hq on;
    # quic_retry on;
    # add_header Alt-Svc 'h3=":443"; ma=86400';

    # Default HTTP server
    server
    {
        listen 80 default_server;
        listen [::]:80 default_server;

        # 防止被扫描器扫描
        location / {
            return 444;
        }

        access_log  /data/www/logs/nxdomain.com.log details;
    }

    # Default HTTPS server
    server
    {
        listen 443 ssl default_server;
        listen [::]:443 ssl default_server;
        # 监听 UDS, 某些情况下非常有用
        # listen unix:/dev/shm/nginx/default-ssl.sock ssl default_server;
        # Nginx 对 QUIC 支持不佳, 我选择关掉, 如果你想试试, 下面这行解除注释. 需要注意: reuseport 只能写一次
        # listen 443 quic reuseport;

        server_name _;
        # 关键: 拒绝未知的 SNI, 防止证书出卖源站
        ssl_reject_handshake on;

        location / {
            return 444;
        }

        access_log  /data/www/logs/nxdomain.com.log details;
    }

    # Include other conf
    include /etc/nginx/conf.d/*.conf;
}
TEXT

# 下面创建各种目录

mkdir /var/cache/nginx
# 配置文件
mkdir /etc/nginx/conf.d
# 证书
mkdir /etc/nginx/certs
# 网页文件
mkdir /data/www
# 访问日志
mkdir /data/www/logs
# 默认网页
mkdir /data/www/default

# 生成 dhparam
openssl dhparam -out /etc/nginx/certs/dhparam.pem 2048

# 添加用户, 设定文件权限
useradd -M -s /sbin/nologin nginx
chown -R nginx:nginx /data/www
chmod -R 700 /data/www
chown -R nginx:nginx /etc/nginx/certs
chmod -R 700 /etc/nginx/certs

# 启动 Nginx!
systemctl daemon-reload && systemctl enable --now nginx
```

<font style="color:rgb(34, 34, 34);">配置文件保存在 </font>`<font style="color:rgb(34, 34, 34);">/etc/nginx/conf.d</font>`<font style="color:rgb(34, 34, 34);"> 下, 证书保存在 </font>`<font style="color:rgb(34, 34, 34);">/etc/nginx/certs</font>`<font style="color:rgb(34, 34, 34);"> 下, 访问日志位于 </font>`<font style="color:rgb(34, 34, 34);">/data/www/logs</font>`<font style="color:rgb(34, 34, 34);">.</font>

## <font style="color:rgb(34, 34, 34);">虚拟内网: </font>[Easytier](https://github.com/EasyTier/EasyTier)
### <font style="color:rgb(34, 34, 34);">安装</font>
```c
mkdir /opt/easytier
cd /opt/easytier

# Latest version: https://github.com/EasyTier/EasyTier/releases
# 个人用着 2.0.3, 能跑就不动了
export EASYTIER_VERSION="2.0.3"

wget https://github.com/EasyTier/EasyTier/releases/download/v$EASYTIER_VERSION/easytier-linux-x86_64-v$EASYTIER_VERSION.zip

# 中国大陆机器, 没配置代理的话, 也可以用 gh-proxy 代理下载
# wget https://gh-proxy.com/https://github.com/EasyTier/EasyTier/releases/download/v$EASYTIER_VERSION/easytier-linux-x86_64-v$EASYTIER_VERSION.zip

unzip easytier-linux-x86_64-v$EASYTIER_VERSION.zip && rm easytier-linux-x86_64-v$EASYTIER_VERSION.zip && mv ./easytier-linux-x86_64/* ./ && rm -r easytier-linux-x86_64

cat << 'EOF' > /etc/systemd/system/easytier.service
[Unit]
Description=EasyTier Service
After=network.target syslog.target
Wants=network.target

[Service]
Type=simple
ExecStart=/opt/easytier/easytier-core -c /opt/easytier/config.toml

[Install]
WantedBy=multi-user.target

EOF
```

### <font style="color:rgb(34, 34, 34);">配置文件</font>
<font style="color:rgb(34, 34, 34);">需要注意, IP 是 CIDR 形式的, 如 IP 是 10.0.0.1, 网段 /16 的话就是</font><font style="color:rgb(34, 34, 34);"> </font>`10.0.0.1/16`<font style="color:rgb(34, 34, 34);">.</font>

<font style="color:rgb(34, 34, 34);">似乎支持 DHCP, 但虚拟内网还是给机器固定 IP 比较好.</font>

```c
export INSTANCE_NAME="{机器代号}"
export HOST_NAME="easytier-{机器代号, 小写}"
export UUID="{uuid, 不能重复哦}"
export IP="{IP}"

cat << EOF > /opt/easytier/config.toml
instance_name = "$INSTANCE_NAME"
hostname = "$HOST_NAME"
instance_id = "$UUID"
ipv4 = "$IP"
dhcp = false
# 默认 rpc_portal 是 127.0.0.1:12588, 不喜欢可以改
# rpc_portal = "127.0.0.1:3260"
listeners = [
  "tcp://0.0.0.0:3261",
  "tcp://[::]:3261",
  "udp://0.0.0.0:3261",
  "udp://[::]:3261",
  "wg://0.0.0.0:3262",
  "wg://[::]:3262"
]
relay-network-whitelist = "Hantong-Easytier"

[network_identity]
network_name = "{网络名称}"
network_secret = "{网络密钥, 不要泄露!!}"

# 如果不希望借助公共服务器组网, 可以配置为自己 VPS 的 IP
# 有多个 IP 依葫芦画瓢就行
[[peer]]
uri = "tcp://{服务器 IP}:3261"
[[peer]]
uri = "udp://{服务器 IP}:3261"

[flags]
# Default transport protocol, 配置为 TCP, 延迟会高一点, 但稳定一点
default_protocol = "tcp"
# TUN Device Name
dev_name = "easytier-tun"
# Encryption support
enable_encryption = true
# IPv6 support
enable_ipv6 = true
# TUN MTU
mtu = 1380
# Mode Latency first
# 这里逻辑我没弄明白说实在的, 就算 default_protocol 设置为 tcp, 这里设置为 true
# 还是会走 UDP. 可能是 BUG 吧.
latency_first = false

[file_logger]
level = "error"
file = "easytier.log"
dir = "/opt/easytier"

[console_logger]
level = "debug"

EOF
```

### <font style="color:rgb(34, 34, 34);">启动</font>
```c
# Firewall Management, 如果是安全组记得去开
ufw allow 3261
ufw allow 3262
ufw allow from {你的虚拟内网 CIDR, 本文例子是 10.0.0.0/16} to any

systemctl daemon-reload && systemctl enable easytier.service --now
```

<font style="color:rgb(34, 34, 34);">可以执行 </font>`<font style="color:rgb(34, 34, 34);">./easytier-cli route</font>`<font style="color:rgb(34, 34, 34);"> 看当前路由状态; </font>`<font style="color:rgb(34, 34, 34);">./easytier-cli peer</font>`<font style="color:rgb(34, 34, 34);"> 看当前加入网络的 peer.</font>  
<font style="color:rgb(34, 34, 34);">如果你改了 rpc_portal, 记得这里也要给个参数 </font>`<font style="color:rgb(34, 34, 34);">-p ***</font>`<font style="color:rgb(34, 34, 34);"> 指定一下.</font>

## <font style="color:rgb(34, 34, 34);">Cloudflared</font>
<font style="color:rgb(34, 34, 34);">Cloudflare 大善人为我们提供了 cloudflared 服务, 做到无需服务器暴露公网端口即可提供网络服务, 最大限度减少攻击面, 推荐使用.</font>

### <font style="color:rgb(34, 34, 34);">安装</font>
<font style="color:rgb(34, 34, 34);">参考: </font>[https://pkg.cloudflare.com/index.html](https://pkg.cloudflare.com/index.html)

```c
# Add cloudflare gpg key
sudo mkdir -p --mode=0755 /usr/share/keyrings
curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee /usr/share/keyrings/cloudflare-main.gpg >/dev/null

# Add this repo to your apt repositories
echo 'deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared any main' | sudo tee /etc/apt/sources.list.d/cloudflared.list

# install cloudflared
sudo apt-get update && sudo apt-get install cloudflared
```

### <font style="color:rgb(34, 34, 34);">使用</font>
+ <font style="color:rgb(34, 34, 34);">登录</font><font style="color:rgb(34, 34, 34);"> </font>[Zero Trust 控制台](https://one.dash.cloudflare.com/)
+ <font style="color:rgb(34, 34, 34);">打开 </font>`网络`<font style="color:rgb(34, 34, 34);"> → </font>`tunnel`
+ <font style="color:rgb(34, 34, 34);">点击 “创建隧道” → “选择 Cloudflared”, 然后命名, 确认即可</font>
+ <font style="color:rgb(34, 34, 34);">点击 </font>`<font style="color:rgb(34, 34, 34);">Debian</font>`<font style="color:rgb(34, 34, 34);">, 复制 </font>`<font style="color:rgb(34, 34, 34);">如果您的计算机上已安装 cloudflared：</font>`<font style="color:rgb(34, 34, 34);"> 下面的买了到目标机器上运行即可</font>
+ <font style="color:rgb(34, 34, 34);">点击 </font>`<font style="color:rgb(34, 34, 34);">← 返回到“隧道”</font>`<font style="color:rgb(34, 34, 34);">, 点击你刚才创建的隧道 (中途有提示就直接确认即可), 点击 “编辑”</font>
+ <font style="color:rgb(34, 34, 34);">添加公共主机名, 按你的需求编辑即可</font>

